<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>demo</title>
</head>
<body>
  <a href="" target="_blank"></a>
  <script>
    // const xmlStr = '<?xml version="1.0" encoding="utf-8" standalone="yes" ?><map><boolean name="color_pick_open" value="false" /><boolean name="log_info_open" value="false" /><boolean name="align_ruler_open" value="false" /><int name="float_icon_pos_y" value="146" /><int name="float_icon_pos_x" value="499" /></map'
    // var parser = new DOMParser();
    // xmlDoc = parser.parseFromString(xmlStr,"text/xml");
    // console.log(xmlDoc)
    // var error = xmlDoc.getElementsByTagName("parsererror");
    // console.log(error)

    // function foo(obj) { 
    //     with (obj) {
    //         a = 2; 
    //     }
    // }
    // var o1 = { a: 3 };
    // var o2 = { b: 3 };

    // foo( o1 );
    // console.log( o1.a ); // 2

    // foo( o2 );
    // console.log( o2.a ); // undefined
    // console.log( a ); // 2——不好，a 被泄漏到全局作用域上了!


    // const arr = [1, 2, 3, 4, 5 ]
    // const num = 3
    // arr.forEach(item => {
    //   if (item == num) {
    //     return
    //   }
    //   console.log(item)
    // })

    // var a;
    // function foo() {
    //   var a = 3; 
    //   console.log( a );
    // }
    // foo();
    // console.log( a ); // 2

    // for (let i = 0; i < 10; i++) {
    //   console.log( i );
    // }
    // console.log('global', i );
    // {
    //   let j;
    //   for (j=0; j<10; j++) {
    //     let i = j; // 每个迭代重新绑定!
    //     console.log( i );
    //   }
    // }
    // Todo:
    // new Promise((resolve, reject) => {
    //   console.log( a );
    //   resolve()
    // }).then( () => {
    //   // 
    //   console.log( a );
    // })
    // var a = 2;


    // foo(); // 不是 ReferenceError, 而是 TypeError!
    // var foo = function bar() { // ...
    // };

    // foo(); // TypeError
    // bar(); // ReferenceError
    // var foo = function bar() { 
    //   // ...
    // };

    // foo(); // 1
    // var foo;
    // function foo() { 
    //     console.log( 1 );
    // }
    // foo = function() { 
    //     console.log( 2 );
    // };

    // foo(); // "b"
    // var a = true
    // if (a) {
    //     function foo() { console.log("a"); } }
    // else {
    //     function foo() { console.log("b"); }
    // }
    // for (var i=1; i<=5; i++) {
    //     setTimeout( function timer() {
    //         console.log( i );
    //     }, i*1000 );
    // }
    // for (var i=1; i<=5; i++) {
    //     (function(j) {
    //         setTimeout(
    //           function timer() {
    //               console.log( j );
    //           }, j*1000 );
    //     })( i );
    // }

    // for (var i=1; i<=5; i++) {
    //   let j = i; // 是的，闭包的块作用域! 
    //   setTimeout(function timer() {
    //       console.log( j );
    //   }, j*1000 );
    // }
    // function CoolModule() {
    //     var something = "cool";
    //     var another = [1, 2, 3];
    //     function doSomething() {
    //         console.log( something );
    //     }
    //     function doAnother() {
    //         console.log( another.join( " ! " ) );
    //     }
    //     return {
    //         doSomething: doSomething,
    //         doAnother: doAnother
    //     }; 
    // }
    // var foo = CoolModule(); 
    // foo.doSomething(); // cool
    // foo.doAnother(); // 1 ! 2 ! 3

    // var data = (function () {
    //   var res = 0
    //   return function (num) {
    //     if (num <=1 ) {
    //       return res
    //     } else {
    //       res += num - 1
    //       // arguments.callee 引用到匿名函数
    //       return arguments.callee.call(this, num - 1)
    //     }
    //     // if (num >= 1) {
    //     //   return res + num + haha.call(this, num - 1)
    //     // } else {
    //     //   return res
    //     // }
    //   }
    // })()
    // console.log(data(5))
    //   function foo(num) {
    //     console.log(arguments)
    //     console.log( "foo: " + num );
    //     // 记录 foo 被调用的次数
    //     // this.count++; 
    //   }
    //   foo(5)
      // console.log()
      // foo.count = 0;
      // console.log(foo)
      // var i;
      // for (i=0; i<10; i++) { 
      //   if (i > 5) {
      //     foo(i)
      //     // foo.call(foo, i );
      //   }
      // }
      // console.log( foo.count );
      // function foo(num) {
      //     console.log( "foo: " + num );// 记录 foo 被调用的次数
      //     this.count++;
      //     console.log( count );
      // }
      // foo.count = 0;

      // for (i=0; i < 10; i++) {
      //     if (i > 5) {
      //         foo( i )
      //     }
      // }
      // // foo: 6
      // // foo: 7
      // // foo: 8
      // // foo: 9
      // // foo 被调用了多少次?
      // console.log( foo.count );
      // console.log( count );
      

        // function foo () {
        //   var a = 2
        //   this.bar()
        // }
        // function bar () {
        //   console.log(this.a)
        // }
        // foo() // undefined
        // function Animal (name, age, status) {
        //   this.name = name
        //   this.age = age
        //   this.status = status
        // }

        // Animal.prototype.eat = function (eating) {
        //   this.status = eating
        // }

        // Animal.prototype.eat = function () {
        // }
        

        // function baz() {
        //     debugger
        //     // 当前调用栈是:baz
        //     // 因此，当前调用位置是全局作用域
        //     console.log( "baz" );
        //     bar(); // <-- bar 的调用位置 
        // }

        // function bar() {
        //     debugger
        //     // 当前调用栈是 baz -> bar
        //     // 因此，当前调用位置在 baz 中
        //     console.log( "bar" );
        //     foo(); // <-- foo 的调用位置 
        // }

        // function foo() {
        //     debugger
        //     // 当前调用栈是 baz -> bar -> foo 
        //     // 因此，当前调用位置在 bar 中
        //     console.log( "foo" );
        // }
        // baz(); // <-- baz 的调用位置

        // function foo() {
        //     debugger // call stack anonymous
        //     console.log( this.a );
        // }
        // var a = 2; 
        // foo(); // 2

        // function foo() { 
        //   "use strict";
        //   console.log( this.a );
        // }
        // var a = 2;
        // foo(); // Uncaught TypeError: Cannot read property 'a' of undefined

        // function foo() {
        //     console.log( this.a );
        // }
        // var a = 2;

        // (function () {
        //     "use strict";
        //     foo(); // 2
        // })();

        // function foo() { 
        //     console.log( this.a );
        // }
        // var obj = {
        //     a: 3,
        //     foo: foo 
        // };
        // obj.foo(); // 3

        // function foo() { 
        //     console.log( this.a );
        // }
        // var obj2 = { 
        //     a: 42,
        //     foo: foo 
        // };
        // var obj1 = { 
        //     a: 2,
        //     obj2: obj2 
        // };
        // obj1.obj2.foo(); // 42

        // function foo() {
        //     console.log( this.a );
        // }
        // var obj = {
        //     a: 2,
        //     foo: foo.bind(obj)
        // };
        // var bar = obj.foo; // 函数别名!
        // var a = "oops, global"; // a 是全局对象的属性 
        // bar(); // "oops, global"
        
        // function foo () {
        //     console.log(this.a)
        // }
        // var obj = {
        //     a: 2
        // }
        // var bar = function () {
        //     foo.call(obj)
        // }
        // bar() // 2
        // setTimeout(bar, 100) // 2
        // bar.apply(window)    // 2

        // function foo (something) {
        //   return this.a + something
        // }
        // var obj = {
        //     a: 2
        // }
        // var bar = function () {
        //     return foo.apply(obj, arguments)
        // }
        // const b = bar(3)
        // console.log(b)

        // function foo (something) {
        //     console.log(this.a, something)
        //     return this.a + something
        // }
        // function weAreTogether (fn, obj) {
        //     return function () {
        //         return fn.apply(obj, arguments)
        //     }
        // }
        // var obj = {
        //     a: 1
        // }
        // const bar = weAreTogether(foo, obj)
        // console.log(bar(1))

        // function foo (something) {
        //     console.log(this.a, something)
        //     return this.a + something
        // }
        // var obj = {
        //     a: 1
        // }
        // const bar = foo.bind(obj)

        // console.log(bar(2))

        // function foo(el) {
        //     console.log( el, this.id );
        // }
        // var obj = {
        //     id: "awesome"
        // };
        // // 调用 foo(..) 时把 this 绑定到 obj 
        // [1, 2, 3].forEach( foo, obj );
        // [1, 2, 3].forEach(item => {
        //   foo.call(obj, item)
        // });  // 不然那要这样写

        // 1 awesome 2 awesome 3 awesome

        // function foo(a) { 
        //     this.a = a;
        // }
        // var bar = new foo(2); 
        // console.log( bar.a ); // 2

        // function foo() {
        //     console.log( this.a );
        // }
        // var obj1 = {
        //     a: 2,
        //     foo: foo.bind(obj2)
        // };
        // var obj2 = {
        //     a: 3,
        //     foo: foo
        // };
        // // obj1.foo(); // 2
        // // obj2.foo(); // 3

        // // obj1.foo.call(obj2) // 3
        // // obj2.foo.call(obj1) // 2
        // obj1.foo()

        // function foo(something) {
        //     this.a = something;
        // }
        // var obj1 = {};
        // var bar = foo.bind( obj1 ); 
        // bar( 2 );

        // console.log( obj1.a ); // 2
        // var baz = new bar(3); 

        // console.log( obj1.a ); // 2 
        // console.log( baz.a ); // 3

        // function test (haha) {
        //   console.log(this.a + haha) // 3
        //   console.log(arguments) // 2, 3, 9
        // }
        // var obj = {
        //   a: 1
        // }
        // const bar = test.bind(obj, 2, 3)
        // bar(9)

        // function foo(p1,p2) { 
        //   this.val = p1 + p2;
        // }
        // var bar = foo.bind( null, "p1" );
        // // 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 
        // // 反正使用 new 时 this 会被修改
        // var baz = new bar('p2')
        // console.log(baz.val) // p1p2

        // function foo() {
        //   console.log( this.a );
        // }
        // var a = 2;
        // foo.call( null ); // 2

        // const arr = []
        // // arr.push(2, 3, 4)
        // Array.prototype.push.apply(arr, [2, 3, 4])
        // console.log(arr)

        // function foo(a,b) {
        //     console.log( "a:" + a + ", b:" + b );
        // }
        // foo(...[2, 3])

        // if (!Function.prototype.softBind) {
        //   Function.prototype.softBind = function(obj) {
        //       var fn = this;
        //       // 捕获所有 curried 参数
        //       var curried = [].slice.call( arguments, 1 ); 
        //       var bound = function() {
        //           return fn.apply((!this || this === (window || global)) ? obj : this,
        //               curried.concat.apply( curried, arguments )
        //           );
        //       };
        //       bound.prototype = Object.create( fn.prototype );
        //       return bound;
        //   };
        // }
        // function foo() {
        //     console.log("name: " + this.name);
        // }
        // var obj = { name: "obj" }, 
        // obj2 = { name: "obj2" }, 
        // obj3 = { name: "obj3" };
        // var fooOBJ = foo.softBind( obj );
        // fooOBJ() // obj

        // obj2.foo = foo.softBind(obj); 
        // obj2.foo() // obj2

        // fooOBJ.call( obj3 ); // obj3
        // setTimeout( obj2.foo, 10 ); // obj

        // function foo() { 
        //     setTimeout(() => {
        //     // 这里的 this 在词法上继承自 foo()
        //         debugger
        //         console.log( this.a );
        //     },100);
        // }
        // var obj = { 
        //     a:2
        // };
        // foo.call( obj ); // 2

        // var prefix = "foo";
        // var myObject = {
        //     [prefix + "bar"]: "hello", 
        //     [prefix + "baz"]: "world"
        // };

        // myObject["foobar"]; // hello
        // myObject["foobaz"]; // world
        // console.log(myObject["foobar"])
        // console.log(myObject["foobaz"])
          
        // const foo = function () {
        //   console.log(this.a)
        // }
        // var obj = {
        //   a: 2,
        //   foo: foo
        // }
        // console.log(
        //   Object.getOwnPropertyDescriptor(obj, 'foo')
        // )

        // var myArray = [ 1, 2, 3 ];
        // var it = myArray[Symbol.iterator]();

        // console.log(it.next())
        // console.log(it.next())
        // console.log(it.next())
        // console.log(it.next())

        // var myObject = { 
        //     a: 2,
        //     b: 3 
        // };

        // for (var v of myObject) { 
        //     console.log( v );
        // }
        // myObject is not iterable 不可迭代的

        // var anotherObject = { 
        //     a:  2
        // };
        // 创建一个关联到 anotherObject 的对象
        // var myObject = Object.create( anotherObject ); 
        // console.log(myObject.a) // 2
        // console.log(myObject)

        // var obj1 = {}
        // var obj2 = {
        //   a: 3
        // }
        // obj1.__proto__ = obj2

        // // console.log(obj1.a)
        // obj1.a = 4
        // console.log(obj1)
        // console.log(obj2)


        // console.log(foo.prototype.__proto__ == Object.__proto__ )
        // console.log(foo.__proto__)

        // var anotherObject = { 
        //   a: 2
        // };
        // var myObject = Object.create( anotherObject );
        // console.log(anotherObject.hasOwnProperty( "a" )); // true
        // console.log(myObject.hasOwnProperty( "a" )); // false
        // console.log(myObject)

        // myObject.a++; // 隐式屏蔽!

        // console.log(anotherObject.a)  // 2
        // console.log(myObject.a)       // 3

        // console.log(myObject.hasOwnProperty( "a" )); // true

        // function Foo() { // ...
        // }
        // var a = new Foo();
        // console.log(Object.getPrototypeOf( a ) === Foo.prototype); // true

        // function Foo() { 
        //     // ...
        // }
        // console.log(Foo.prototype.constructor === Foo); // true
        // console.log(Foo.prototype)

        // var a = new Foo();
        // console.log(a.constructor === Foo.prototype.constructor); // true


        function NothingSpecial() { 
            console.log( "Don't mind me!" );
        }
        var a = new NothingSpecial();

        console.log(a)




  </script>
</body>
</html>