# 回调

在所有这些示例中，函数都是作为**回调(callback)**使用的，因为它是事件循环“回头调 用”到程序中的目标，队列处理到这个项目的时候会运行它。

到目前为止，回调是编写和处理 JavaScript 程序异步逻辑的最常用方式。确实，回调是这门语言中最基础的异步模式。

很多开发者因为更好的异步模式 promise(promise 也是“承诺、希望”的意思，此处一语双关)而激动不已。但是，只有理解了某种抽象的目 标和原理，才能有效地应用这种抽象机制。


## 2.1 continuation

一旦我们以回调函数的形式引入了单个 continuation(或者几十个，就像很多程序所做的那 样!)，我们就容许了大脑工作方式和代码执行方式的分歧。一旦这两者出现分歧(这远 不是这种分歧出现的唯一情况，我想你明白这一点!)，我们就得面对这样一个无法逆转的事实:代码变得更加难以理解、追踪、调试和维护。(回调地狱 Callback hell)


## 2.2 顺序的大脑


有时也被称为毁灭金字塔(pyramid of doom)

但实际上回调地狱与嵌套和缩进几乎没有什么关系。它引起的问题要比这些严重得多。本章后面的内容会就此类问题的现象和原因展开讨论。

## 2.3 信任问题

让我们再次思考一下程序中把回调 continuation(也就是后半部分)的概念:

```js
// A
ajax( "..", function(..){
    // C 
} );
// B
```
// A和// B发生于现在，在JavaScript主程序的直接控制之下。而// C会延迟到将来发 生，并且是在第三方的控制下——在本例中就是函数 ajax(..)。从根本上来说，这种控制 的转移通常不会给程序带来很多问题。

但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调 驱动设计最严重(也是最微妙)的问题。它以这样一个思路为中心:有时候 ajax(..)(也 就是你交付回调 continuation 的第三方)不是你编写的代码，也不在你的直接控制下。多 数情况下，它是某个第三方提供的工具。

我们把这称为**控制反转**(inversion of control)，也就是把自己程序一部分的执行控制交给某 个第三方。在你的代码和第三方工具(一组你希望有人维护的东西)之间有一份并没有明 确表达的契约。

## 总结

回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟，对于异步编程领域的发展，回调已经不够用了。

第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流 程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致坏 bug。

我们需要一种更同步、更顺序、更阻塞的的方式来表达异步，就像我们的大脑一样。


第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。这种控制转移导 致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。

可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更 笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到 bug 的影响才会 被发现。








