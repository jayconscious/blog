<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- <button id="btn">
        防抖测试
    </button> -->

    <script>

        // Todo: 两数之和 - 哈希
        // https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
        // 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
        // 你可以按任意顺序返回答案。
        // 示例 1：
        // 输入：nums = [2,7,11,15], target = 9
        // 输出：[0,1]
        // 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

        // 示例 2：
        // 输入：nums = [3,2,4], target = 6
        // 输出：[1,2]

        // 示例 3：
        // 输入：nums = [3,3], target = 6
        // 输出：[0,1]

        // 方法一：循环遍历
        // function solution(nums, target) {
        //     for (let left = 0; left < nums.length; left++) {
        //         for (let right = 1; right < nums.length; right++) {
        //             if (nums[left] + nums[right] == target && left != right) {
        //                 return [left, right]
        //             }
        //         }
        //     }
        //     return []
        // }

        // 方法二：has表 - 查找表法
        // function solution(nums, target) {
        //     let map = new Map()
        //     for (let i = 0; i < nums.length; i++) {
        //         let currNum = nums[i]
        //         let restNum = target - currNum
        //         if (map.has(restNum)) {
        //             return [i, map.get(restNum)]
        //         } else {
        //             map.set(currNum, i)
        //         }
        //     }
        // }
        // console.log(solution([2, 7, 11, 15], 9))
        // console.log(solution([3, 2, 4], 6))
        // console.log(solution([3, 3], 6))


        // Todo: 最长无重复子串的长度
        // 'wasdiahgjkd'
        // function solution(strs) {
        //     let left = 0, strSet = new Set(), maxLength = 0;
        //     for (let right = 0; right < strs.length; right++) {
        //         while (strSet.has(strs[right])) {
        //             strSet.delete(strs[left])  // 从后面开始删除，直到没有重复
        //             left++
        //         }
        //         strSet.add(strs[right])
        //         maxLength = Math.max(maxLength, strSet.size)
        //     }
        //     return maxLength
        // }
        // console.log(solution('wasdiahgjkd'))


        // Todo:  合并区间
        // 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
        // 示例 1：
        // 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
        // 输出：[[1,6],[8,10],[15,18]]
        // 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]

        // 示例 2：
        // 输入：intervals = [[1,4],[4,5]]
        // 输出：[[1,5]]
        // 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

        // 解题思路：
        // 1. 先将原数组以左端点排序
        // 2. 然后比较当前数组的 start, end 和 preEnd 的大小关系
        // 3. 如果 start > preEnd, 则不连续；否则：preEnd >= start && end > preEnd, 说明有交集，需要合并

        // function solution(intervals) {
        //     let res = [];
        //     intervals.sort((a, b) => a[0] - b[0])
        //     let preIndex = -1

        //     intervals.forEach(interval => {
        //         let [preStart, preEnd] = res[preIndex] ? res[preIndex] : []
        //         let [start, end] = interval
        //         if (!res.length || start > preEnd) {
        //             res.push(interval)
        //             preIndex++
        //         } else if (end > preEnd) {
        //             // 合并区间
        //             res[preIndex][1] = end
        //         }
        //     });
        //     return res;
        // }

        // console.log(solution([[1, 3], [2, 6], [8, 10], [15, 18]])) // [[1,6],[8,10],[15,18]]
        // console.log(solution([[1,4],[4,5]])) // [[1,5]]


        // 最大回文长度 'abcbaccc'

        // function isHuiWen(s, left, right) {
        //     while (left < right) {
        //         if (s[left] != s[right]) {
        //             return false
        //         }
        //         left++
        //         right--
        //     }
        //     return true
        // }
        // function solution(s) {
        //     if (s.length < 2) {
        //         return
        //     }
        //     let begin = 0, maxLen = 1
        //     for (let i = 0; i < s.length - 1; i++) {
        //         for (let j = 1; j < s.length; j++) {
        //             let currLen = j - i + 1
        //             if (currLen > maxLen && isHuiWen(s, i, j)) {
        //                 maxLen = currLen
        //                 begin = i
        //             }
        //         }
        //     }
        //     return s.substr(begin, maxLen)
        // }
        // console.log(solution('abcbaccc'))


        // 防抖问题 - 解决什么问题，如何在单位时间内，控制行为触发的频次
        // 节流问题 - 解决什么问题，如何在单位时间内，控制行为触发的频次

        // 当你使用 clearTimeout 取消一个尚未执行的 setTimeout 回调函数时，该回调函数将不会被执行。
        // 关键点：
        // setTimeout 会返回一个唯一的定时器 ID（数字），用于后续取消。
        // clearTimeout 通过传入这个 ID，可以取消尚未执行的定时任务。
        // 如果回调尚未触发，调用 clearTimeout 后，回调会被彻底移除，永远不会执行。
        // 如果回调已执行，clearTimeout 不会有任何效果（但也不会报错）。

        // function debounce(fn, delay = 1000) {
        //     let timer
        //     return function (...args) {
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //         }, delay)
        //     }
        // }

        // function throttle(fn, delay = 1000) {
        //     let flag = false, timer
        //     return (...args) => {
        //         if (flag) return;
        //         flag = true;
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args);
        //             flag = false;
        //         }, delay);
        //     }
        // }
        // const btnDom = document.getElementById('btn')
        // function print(e) {
        //     console.log('e', e)
        // }
        // // btnDom.addEventListener('click', debounce(print), false)
        // btnDom.addEventListener('click', throttle(print), false)

        // // debounce
        // // 使用定时器来控制触发频次
        // function debounce(fn, delay = 1000) {
        //     let timer = null;
        //     return function (...args) {
        //         // 都是从1开始的
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //         }, delay);
        //     }
        // }

        // 其他算法题
        // Todo: 手写-字符串最长的不重复子串
        // 题目描述
        // 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
        // 输入: s = "abcabcbb"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3
        // 输入: s = "bbbbb"
        // 输出: 1
        // 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
        // 输入: s = "pwwkew"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
        // 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
        // 示例 4:
        // 输入: s = ""
        // 输出: 0
        // function solution(strs) {
        //     let left = 0, charSet = new Set(), maxLen = 0
        //     for (let right = 0; right < strs.length; right++) {
        //         while (charSet.has(strs[right])) {
        //             charSet.delete(strs[left])
        //             left++
        //         }
        //         charSet.add(strs[right])
        //         maxLen = Math.max(maxLen, right - left + 1);
        //     }
        //     return maxLen
        // }
        // console.log(solution("pwwkew"))
        // console.log(lengthOfLongestSubstring("pwwkew"))

        // Todo: 对象扁平化 flatten
        const obj = {
            a: {
                b: 1,
                c: 2,
                d: { e: 5 }
            },
            b: [1, 3, { a: 2, b: 3 }],
            c: 3
        }
        // flatten(obj) 结果返回如下
        // {
        //  'a.b': 1,
        //  'a.c': 2,
        //  'a.d.e': 5,
        //  'b[0]': 1,
        //  'b[1]': 3,
        //  'b[2].a': 2,
        //  'b[2].b': 3
        //   c: 3
        // }

        // function getType(element) {
        //     return Object.prototype.toString.call(element).slice(8, -1).toLowerCase();

        //     // const typeStr = Object.prototype.toString.call(element).slice(8, -1)
        //     // console.log(typeof typeStr)
        //     // return typeStr
        //     // .toLowerCase()

        // }
        // function flattenObject(sourceObject) {
        //     const flattenedResult = {};

        //     function flatten(currentValue, currentPath) {
        //         const valueType = getType(currentValue);

        //         if (valueType === 'object') {
        //             for (const key in currentValue) {
        //                 if (Object.prototype.hasOwnProperty.call(currentValue, key)) {
        //                     const nestedValue = currentValue[key]; // nestedValue（更语义化，表示嵌套的值）
        //                     const newPath = currentPath ? `${currentPath}.${key}` : key; // newPath（更符合逻辑，表示新生成的路径）
        //                     flatten(nestedValue, newPath); 
        //                 }
        //             }
        //         } else if (valueType === 'array') {
        //             currentValue.forEach((item, index) => {
        //                 const newPath = `${currentPath}.${index}`;
        //                 flatten(item, newPath);
        //             });
        //         } else {
        //             flattenedResult[currentPath] = currentValue;
        //         }
        //     }
        //     flatten(sourceObject, '');
        //     return flattenedResult;
        // }
        // console.log(objectFlatten(obj))

        // throttle 节流
        // function throttle(fn, delay = 300) {
        //     let timer;
        //     return function (...args) {
        //         if (timer) return
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //             timer = null
        //         }, delay);
        //     }
        // }

        // Todo: 使用 setTimeout 模拟 setInterval
        // 








































    </script>
</body>

</html>