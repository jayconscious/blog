<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>


    <script>

        // Todo: 两数之和 - 哈希
        // https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
        // 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
        // 你可以按任意顺序返回答案。
        // 示例 1：
        // 输入：nums = [2,7,11,15], target = 9
        // 输出：[0,1]
        // 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

        // 示例 2：
        // 输入：nums = [3,2,4], target = 6
        // 输出：[1,2]

        // 示例 3：
        // 输入：nums = [3,3], target = 6
        // 输出：[0,1]

        // 方法一：循环遍历
        // function solution(nums, target) {
        //     for (let left = 0; left < nums.length; left++) {
        //         for (let right = 1; right < nums.length; right++) {
        //             if (nums[left] + nums[right] == target && left != right) {
        //                 return [left, right]
        //             }
        //         }
        //     }
        //     return []
        // }

        // 方法二：has表 - 查找表法
        // function solution(nums, target) {
        //     let map = new Map()
        //     for (let i = 0; i < nums.length; i++) {
        //         let currNum = nums[i]
        //         let restNum = target - currNum
        //         if (map.has(restNum)) {
        //             return [i, map.get(restNum)]
        //         } else {
        //             map.set(currNum, i)
        //         }
        //     }
        // }
        // console.log(solution([2, 7, 11, 15], 9))
        // console.log(solution([3, 2, 4], 6))
        // console.log(solution([3, 3], 6))


        // Todo: 最长无重复子串的长度
        // 'wasdiahgjkd'
        // function solution(strs) {
        //     let left = 0, strSet = new Set(), maxLength = 0;
        //     for (let right = 0; right < strs.length; right++) {
        //         while (strSet.has(strs[right])) {
        //             strSet.delete(strs[left])  // 从后面开始删除，直到没有重复
        //             left++
        //         }
        //         strSet.add(strs[right])
        //         maxLength = Math.max(maxLength, strSet.size)
        //     }
        //     return maxLength
        // }
        // console.log(solution('wasdiahgjkd'))


        // Todo:  合并区间
        // 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
        // 示例 1：
        // 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
        // 输出：[[1,6],[8,10],[15,18]]
        // 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]

        // 示例 2：
        // 输入：intervals = [[1,4],[4,5]]
        // 输出：[[1,5]]
        // 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

        // 解题思路：
        // 1. 先将原数组以左端点排序
        // 2. 然后比较当前数组的 start, end 和 preEnd 的大小关系
        // 3. 如果 start > preEnd, 则不连续；否则：preEnd >= start && end > preEnd, 说明有交集，需要合并

        // function solution(intervals) {
        //     let res = [];
        //     intervals.sort((a, b) => a[0] - b[0])
        //     let preIndex = -1

        //     intervals.forEach(interval => {
        //         let [preStart, preEnd] = res[preIndex] ? res[preIndex] : []
        //         let [start, end] = interval
        //         if (!res.length || start > preEnd) {
        //             res.push(interval)
        //             preIndex++
        //         } else if (end > preEnd) {
        //             // 合并区间
        //             res[preIndex][1] = end
        //         }
        //     });
        //     return res;
        // }

        // console.log(solution([[1, 3], [2, 6], [8, 10], [15, 18]])) // [[1,6],[8,10],[15,18]]
        // console.log(solution([[1,4],[4,5]])) // [[1,5]]

        function isHuiWen(s, left, right) {
            while (left < right) {
                if (s[left] != s[right]) {
                    return false
                }
                left++
                right--
            }
            return true
        }

        // 回文 'abcbaccc'
        function solution(s) {
            if (s.length < 2) {
                return
            }
            let begin = 0, maxLen = 1
            for (let i = 0; i < s.length - 1; i++) {
                for (let j = 1; j < s.length; j++) {
                    let currLen = j - i + 1
                    if (currLen > maxLen && isHuiWen(s, i, j)) {
                        maxLen = currLen
                        begin = i
                    }
                }
            }
            return s.substr(begin, maxLen)
        }
        console.log(solution('abcbaccc'))


        





















    </script>
</body>

</html>