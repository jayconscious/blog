<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hand-review-2</title>
</head>

<body>
    <script>
        // Todo: js反转链表
        // let head = [1, 2, 3, 4, 5]
        // class ListNode {
        //     constructor(value, next) {
        //         this.value = value
        //         this.next = next
        //     }
        // }
        // // 将数组转换为链表
        // function arrayToList(arr) {
        //     if (!arr.length) {
        //         return
        //     }
        //     let head = new ListNode(arr[0])
        //     let current = head
        //     for (let i = 1; i < arr.length; i++) {
        //         let item = arr[i]
        //         current.next = new ListNode(arr[i])
        //         current = current.next
        //     }
        //     return head
        // }
        // // let curr = arrayToList(head)
        // // printList(curr)
        // function reverseList(head) {
        //     let pre = head, curr = null
        //     while (pre) {
        //         let t = pre.next
        //         pre.next = curr
        //         curr = pre
        //         pre = t
        //     }
        //     return curr
        // }
        // let curr = arrayToList(head)
        // printList(reverseList(curr))
        // function ListNode(val, next) {
        //     this.val = (val === undefined ? 0 : val)
        //     this.next = (next === undefined ? null : next)
        // }
        // var reverseList = function (head) {
        //     let temp = new ListNode();
        //     let next = null;
        //     while (head) {
        //         next = head.next;//下一个节点
        //         head.next = temp.next;
        //         temp.next = head;//head接在temp的后面
        //         head = next;//head向后移动一位
        //     }
        //     return temp.next;
        // };
        // let head = [1,2,3,4,5]
        // console.log(reverseList(head))

        // Todo: 数字之和是 N 数字之和的两倍
        // 编写一个js函数 function solution (N);
        // 给定一个整数 N，返回大于 N 的最小整数，其数字之和是 N 数字之和的两倍。
        // 例子:
        // 1.给定 N=14，函数应该返回 19。19 的数字和(1+9=10)是 14 的数字和(1+4=5)的两倍。
        // 2.给定 N=10，该函数应该返回 11。
        // 3.假设 N=99，该函数应该返回 9999。假设:
        // ·N是[1..500]范围内的整数

        // function numSum(num) {
        //     return (num + '').split('').reduce(function name(sum, curr) {
        //         return sum + Number(curr)
        //     }, 0)
        // }

        // function solution(N) {
        //     let result = void 0, isHas = false
        //     for (let i = N; i < 9999; i++) {
        //         if (isHas) return result
        //         if (numSum(i) / numSum(N) == 2) {
        //             result = i
        //             isHas = true
        //         }
        //     }
        //     return result
        // }
        // console.log(solution(14))

        // function sumOfDigits(num) {
        //     // 计算数字的各位数字之和
        //     return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        // }

        // function solution(N) {
        //     const targetSum = sumOfDigits(N) * 2;  // 目标数字之和是 N 数字之和的两倍
        //     let candidate = N + 1;  // 从 N+1 开始查找

        //     // 不断递增查找，直到找到满足条件的数字
        //     while (sumOfDigits(candidate) !== targetSum) {
        //         candidate++;
        //     }

        //     return candidate;  // 返回找到的数字
        // }

        // // 示例测试
        // console.log(solution(14));  // 输出: 19
        // console.log(solution(10));  // 输出: 11
        // console.log(solution(99));  // 输出: 9999


        // Todo: 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
        // 实现 LRUCache 类：
        // LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
        // int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
        // void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；
        // 如果不存在，则向缓存中插入该组 key-value 。
        // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        // 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
        // 输入
        // ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
        // [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

        // 输出
        // [null, null, null, 1, null, -1, null, -1, 3, 4]
        // 解释
        // LRUCache lRUCache = new LRUCache(2);
        // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // lRUCache.get(1);     // 返回 1
        // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // lRUCache.get(2);     // 返回 -1 (未找到)
        // lRUCache.put(4, 4);  // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
        // lRUCache.get(1);     // 返回 -1 (未找到)
        // lRUCache.get(3);     // 返回 3
        // lRUCache.get(4);     // 返回 4

        /**
        * @param {number} capacity
        */
        // var LRUCache = function (capacity) {
        //     this.capacity = capacity;
        //     this.map = new Map();
        // };
        // /** 
        //  * @param {number} key
        //  * @return {number}
        //  */
        // LRUCache.prototype.get = function (key) {
        //     if (this.map.has(key)) {
        //         let val = this.map.get(key)
        //         this.map.delete(key);
        //         this.map.set(key, val); // 放到最前面
        //         return val
        //     } else {
        //         return -1
        //     }
        // };

        // /** 
        //  * @param {number} key 
        //  * @param {number} value
        //  * @return {void}
        //  */
        // LRUCache.prototype.put = function (key, value) {
        //     if (this.map.has(key)) {
        //         this.map.delete(key);
        //     }
        //     this.map.set(key, value);
        //     // 如果超出怎么办？
        //     if (this.map.size > this.capacity) {
        //         // this.map.keys() 返回一个迭代器对象
        //         // next().value
        //         // 返回第一个 key
        //         this.map.delete(this.map.keys().next().value);
        //     }
        // };

        // /**
        //  * Your LRUCache object will be instantiated and called as such:
        //  * var obj = new LRUCache(capacity)
        //  * var param_1 = obj.get(key)
        //  * obj.put(key,value)
        //  */
        // // let lRUCache = new LRUCache(2);
        // // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // // console.log('lRUCache', lRUCache)

        // // console.log(lRUCache.get(1));     // 返回 1
        // // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // // console.log(lRUCache.get(2));     // 返回 -1

        // const myMap = new Map();
        // myMap.set("0", "foo");
        // myMap.set(1, "bar");
        // myMap.set({}, "baz");
        // const mapIter = myMap.keys();
        // console.log(mapIter.next());
        // console.log(mapIter.next().value); // "0"
        // console.log(mapIter.next().value); // 1
        // console.log(mapIter.next().value); // {}

        // Todo:  一个跨域不存在的404请求
        // - [x] 解答：预检请求没有拿到 access-control-allow-origin 相关字段配置(服务器端)，
        // 那么正确的请求会被浏览器 block 掉，并且会报 cors error
        // 使用 Fetch API 发起跨域请求
        // fetch('111', {
        //     method: 'GET', // 或 'POST' 根据实际需要
        //     headers: {
        //         'Content-Type': 'application/json'
        //     },
        //     // 其他可选配置...
        // })
        //     .then(response => response.json()) // 解析 JSON 响应
        //     .then(data => {
        //         console.log('数据:', data);
        //     })
        //     .catch(error => {
        //         console.error('请求失败:', error);
        //     });


        // Todo: 手写 - 如何找到数组中第一个没出现的最小正整数怎么优化（字节）
        // 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
        // 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
        // 示例 1：
        // 输入：nums = [1,2,0]
        // 输出：3

        // 示例 2：
        // 输入：nums = [3,4,-1,1]
        // 输出：2

        // 示例 3：
        // 输入：nums = [7,8,9,11,12]
        // 输出：1
        // 算法题

        // 思路：前后差值是1说明连续，
        // 1, 2, 4
        // function getMinNumNoShow (arr) {
        //   let minNum = null
        //   let list = arr.filter(item => item > 0).sort()
        //   for (let i = 0; i < list.length; i++) {
        //     const current = list[i]
        //     const next = list[i+1]
        //     if (i == 0 && 1 != current) {
        //       minNum = 1
        //       break
        //     }
        //     if ((current && next && (next - current) > 1) || !next) {
        //       minNum = current + 1
        //       break
        //     }
        //   }
        //   return minNum
        // }
        // const nums = [1,2,0]
        // const nums = [7,8,9,11,12]
        // const nums = [3,4,-1,1]
        // console.log(getMinNumNoShow(nums))
        // 算法复杂度如何计算 O(3n)
        // 一次循环搞定
        // Why O(n)


        // Todo: 手写-怎么在指定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）
        // const testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
        // const n = 5
        // // => [1, 2, 3, 4, 5, 6]
        // function getArrByParams (arr, n) {
        //   let result = []
        //   for (let i = 0; i < arr.length; i++) {
        //     const element = arr[i];
        //     if (result.indexOf(element) == -1) {
        //       result.push(element)
        //       if (result.length == n) {
        //         break;
        //       }
        //     }
        //   }
        //   return result
        // }
        // console.log(getArrByParams(testArray, n))
        // 算法复杂度
        // Why O(n)


        // Todo: 三数之和
        // 给你一个整数数组 nums ，判断是否存在三元组[nums[i], nums[j], nums[k]] 
        // 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。
        // 请你返回所有和为 0 且不重复的三元组。
        // 注意：答案中不可以包含重复的三元组。

        // function threeSum(nums) {
        //     const res = [];
        //     const n = nums.length;
        //     // 三层循环遍历
        //     for (let i = 0; i < n - 2; i++) {
        //         for (let j = i + 1; j < n - 1; j++) {
        //             for (let k = j + 1; k < n; k++) {
        //                 // 检查和是否为 0
        //                 if (nums[i] + nums[j] + nums[k] === 0) {
        //                     // 将三元组添加到结果中
        //                     const triplet = [nums[i], nums[j], nums[k]];
        //                     // 防止添加重复的三元组
        //                     // Tip: 这个判断不能保证组合内部元素不重复，如果 nums 有重复的元素的话，有几率产生重复的组合。
        //                     if (!res.some(item =>
        //                         item[0] === triplet[0] && item[1] === triplet[1] && item[2] === triplet[2]
        //                     )) {
        //                         res.push(triplet);
        //                     }
        //                 }
        //             }
        //         }
        //     }
        //     return res;
        // }
        // // 示例
        // console.log(threeSum([-1, 0, 1, 2, -1, -4]));

        // Todo: 第一种解法：三层 for 循环暴力破解
        // function threeSum(nums) {
        //     const result = [];
        //     const n = nums.length;
        //     // 先对数组排序，方便去重，从小到大排序
        //     nums.sort((a, b) => a - b);
        //     // 三层循环暴力枚举
        //     for (let i = 0; i < n - 2; i++) {
        //         // 跳过重复的 a
        //         // 为什么这样就可以跳过呢？
        //         if (i > 0 && nums[i] === nums[i - 1]) continue;
        // 
        //         for (let j = i + 1; j < n - 1; j++) {
        //             // 关注起始位的索引参数
        //             // 跳过重复的 b
        //             if (j > i + 1 && nums[j] === nums[j - 1]) continue;
        //             // 保证索引大于前一个，并且两两不相同即可保证
        //             for (let k = j + 1; k < n; k++) {
        //                 // 跳过重复的 c
        //                 if (k > j + 1 && nums[k] === nums[k - 1]) continue;
        //                 // 检查是否满足 a + b + c = 0
        //                 if (nums[i] + nums[j] + nums[k] === 0) {
        //                     result.push([nums[i], nums[j], nums[k]]);
        //                 }
        //             }
        //         }
        //     }
        //     return result;
        // }
        // // 示例
        // const nums = [-1, 0, 1, 2, -1, -4];
        // const result = threeSum(nums);
        // console.log(result); // 输出: [[-1, -1, 2], [-1, 0, 1]]

        // 第二种：双指针索引法
        // 
        // function threeSum(nums) {
        //     const result = [];
        //     const n = nums.length;
        //     // 先对数组排序
        //     nums.sort((a, b) => a - b);

        //     // 遍历数组，固定 a
        //     for (let i = 0; i < n - 2; i++) {
        //         // 跳过重复的 a
        //         // 因为数组已经排序过了，所以只要判断相邻两两不相同，
        //         // 即可保证，当前三元组的第一个元素是不重复的
        //         if (i > 0 && nums[i] === nums[i - 1]) continue;
        //         // 初始化双指针
        //         let left = i + 1;
        //         let right = n - 1;
        //         // 双指针寻找 b 和 c
        //         while (left < right) {
        //             const sum = nums[i] + nums[left] + nums[right];
        //             if (sum < 0) {
        //                 left++; // 和太小，左指针右移
        //             } else if (sum > 0) {
        //                 right--; // 和太大，右指针左移
        //             } else {
        //                 // 找到满足条件的三元组
        //                 result.push([nums[i], nums[left], nums[right]]);
        //                 // 跳过重复的 b 和 c
        //                 while (left < right && nums[left] === nums[left + 1]) {
        //                     left++;
        //                 }
        //                 while (left < right && nums[right] === nums[right - 1]) {
        //                     right--;
        //                 }
        //                 // 移动指针
        //                 left++;
        //                 right--;
        //             }
        //         }
        //     }

        //     return result;
        // }

        // // 示例
        // const nums = [-1, 0, 1, 2, -1, -4];
        // const result = threeSum(nums);
        // console.log(result); // 输出: [[-1, -1, 2], [-1, 0, 1]]


        // Todo: 数组中的第K个最大元素
        // 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
        // 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
        // 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 如何使用大顶堆解决问题呢？

        // function solution(nums, k) {
        //     nums.sort((a, b) => b - a)
        //     return nums[k - 1]
        // }


        // Todo: 最大子数组和
        // 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），
        // 返回其最大和。子数组是数组中的一个连续部分。

        // var maxSubArray = function (nums) {
        //     let len = nums.length, maxSum = 0
        //         , begin = 0, end = 0;
        //     for (let i = 0; i < len; i++) {
        //         if (len == 1) {
        //             return nums[0]
        //         }
        //         for (let j = 1; j < len; j++) {
        //             if (j > i) {
        //                 // debugger
        //                 let vaildNums = nums.slice(i, j + 1)
        //                 let sum = vaildNums.reduce(
        //                     function (sum, num) {
        //                         return sum + num
        //                     }
        //                 )
        //                 maxSum = Math.max(maxSum, sum)
        //             }
        //         }
        //     }
        //     return maxSum;
        // };

        // function maxSubArray(nums) {
        //     let preSum = 0, maxSum = nums[0] //Tip: 假定第一个最大
        //     nums.forEach(num => {
        //         preSum = Math.max(preSum + num, num)
        //         maxSum = Math.max(maxSum, preSum)
        //     });
        //     return maxSum
        // }

        // console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))
        // console.log(maxSubArray([1]))
        // console.log(maxSubArray([5, 4, -1, 7, 8]))

        // Todo: 洗牌算法
        // 这道题是这样的给你一个数组，要你写一个函数，使得数组的排列顺序随机。
        // 这一道题要用到洗牌算法。

        // 1. 不均匀分布的问题 - 极端情况会和原排序一样，并不会打乱数组
        // sort(() => Math.random() - 0.5) 生成的是一个不稳定的排序，并且 不保证每个元素都有均等的概率出现在每个位置。因为 Math.random() 生成的随机数是伪随机的，并且 sort 方法基于该随机数进行比较，无法保证每一对元素之间有平等的交换机会。
        // 例如：对于两个相邻的元素，Math.random() - 0.5 生成的值有可能是负数、零或正数，这个随机结果会影响它们的顺序，但是这种随机交换的概率并不是均匀的，导致打乱结果不完全公平。
        // 在实际测试中，使用这种方法可能会导致某些元素比其他元素更容易出现在某些位置上。
        // 2. sort 的稳定性问题 sort() 的 稳定性 在不同的浏览器和 JavaScript 引擎中可能不同。稳定性指的是如果两个元素的排序是相等的，它们相对的位置应该保持不变。而 Math.random() 产生的排序是无序的，它实际上并不能确保排序的稳定性。
        // 因此，使用 sort 来排序数组时，可能出现元素顺序无法预测的情况。
        // 3. 性能问题
        // 虽然 sort() 看似简单，但它的时间复杂度是 O(n log n)。而 Fisher-Yates 洗牌算法 只需要 O(n) 时间复杂度，就能实现正确的随机打乱。
        // 由于 sort(() => Math.random() - 0.5) 依赖于排序算法，排序本身会引入不必要的性能开销。如果数组较大，使用 sort 来打乱数组会导致性能低下，尤其是当 n 非常大的时候。
        // 4. 不能保证“真正的”随机性
        // Math.random() 本身是一个伪随机数生成器，它的实现可能导致一些偏差，特别是对于大规模的数据集。在一些情况下，基于 Math.random() 的排序可能会在实际应用中偏离预期的随机性分布。
        // 如何解决这些问题？
        // 使用 Fisher-Yates 洗牌算法
        // Fisher-Yates（又称 Knuth 洗牌算法）是 O(n) 时间复杂度的高效算法，能够保证每个元素有 均等的概率 出现在每个位置，而且它的实现简单且均匀分布。

        // let arr = [1, 2, 3, 4, 5]
        // function shuffle(nums) {
        //     let len = nums.length
        //     for (let i = 0; i < len; i++) {
        //         let j = Math.floor(Math.random() * (i + 1)); // 这里一定要写分号
        //         [nums[j], nums[i]] = [nums[i], nums[j]]
        //     }
        //     return nums
        // }
        // console.log(shuffle(arr))

        // Todo: 合并有序俩表
        // 
        // const arr1 = [1, 3, 7]
        // const arr2 = [2, 4, 6]
        // class ListNode {
        //     constructor(value, next) {
        //         this.value = value
        //         this.next = next
        //     }
        // }
        // // 将数组转换为链表
        // function arrayToList(arr) {
        //     if (!arr.length) {
        //         return
        //     }
        //     let head = new ListNode(arr[0])
        //     let current = head
        //     for (let i = 1; i < arr.length; i++) {
        //         let item = arr[i]
        //         current.next = new ListNode(item)
        //         // Todo: 把索引往下传递
        //         current = current.next
        //     }
        //     return head
        // }

        // console.log(arrayToList(arr))
        // function mergeTwoList(list1, list2) {
        //     if (list1 == null) {
        //         return list2
        //     } else if (list2 == null) {
        //         return list1
        //     } else if (list1.value < list2.value) {
        //         list1.next = mergeTwoList(list1.next, list2)
        //         return list1
        //     } else {
        //         list2.next = mergeTwoList(list1, list2.next)
        //         return list2
        //     }
        // }

        // console.log(mergeTwoList(arrayToList(arr1), arrayToList(arr2)))


        // Todo: 请求并发控制
        // 
        // const request = function (url) {
        //     return new Promise(function (resolve, reject) {
        //         setTimeout(() => {
        //             resolve(url)
        //         }, 2000 * Math.random());
        //     })
        // }

        // class RequestConcurrentControl {
        //     constructor(nums) {
        //         this.maxNums = nums
        //         this.isRunningCount = 0
        //         this.queue = []
        //     }

        //     enqueue(url) {
        //         const that = this
        //         return new Promise(function (resolve, reject) {
        //             const task = function () {
        //                 that.isRunningCount++
        //                 request(url).then(resolve).catch(reject).finally(() => {
        //                     that.isRunningCount--
        //                     that.dequeue()
        //                 })
        //             }
        //             that.queue.push(task)
        //             that.dequeue()
        //         })
        //     }

        //     dequeue() {
        //         if ((this.isRunningCount < this.maxNums) && this.queue.length) {
        //             const task = this.queue.shift()
        //             task()
        //         }
        //     }
        // }

        // // 使用ø
        // let rcc = new RequestConcurrentControl(3)
        // const urlList = ['url1', 'url2', 'url3', 'url4', 'url5', 'url6', 'url7', 'url8']
        // urlList.forEach(url => {
        //     // 实现效果 
        //     rcc.enqueue(url).then(url => {
        //         console.log(url + ' end')
        //     })
        // })


        // Todo:
        // 要实现一个最大请求控制的功能，可以通过一个队列来管理请求，并使用计数器来限制同时运行的请求数量。
        // 以下是实现 add、step 和 remove 等方法的代码示例：

        // class RequestController {
        //     constructor(maxNums) {
        //         this.maxConcurrentCount = maxNums
        //         this.queue = []
        //         this.runningCount = 0
        //     }

        //     add(requestFn) {
        //         return new Promise((resolve, reject) => {
        //             this.queue.push({ requestFn, resolve, reject })
        //             this.step()
        //         })
        //     }

        //     step() {
        //         while ((this.runningCount < this.maxConcurrentCount) && this.queue.length) {
        //             const { requestFn, resolve, reject } = this.queue.shift()
        //             this.runningCount++
        //             requestFn().then(resolve).catch(reject).finally(() => {
        //                 this.runningCount--
        //                 this.step()
        //             })
        //         }
        //     }

        //     remove(requestFn) {
        //         const index = this.queue.findIndex(item => item.requestFn == requestFn)
        //         if (index != -1) {
        //             this.queue.splice(index, 1)
        //         }
        //     }
        // }

        // // 模拟一个异步请求函数
        // function mockRequest(id, delay) {
        //     return new Promise((resolve) => {
        //         setTimeout(() => {
        //             console.log(`请求 ${id} 完成`);
        //             resolve(`请求 ${id} 的结果`);
        //         }, delay);
        //     });
        // }

        // // 创建一个最大并发数为 2 的请求控制器
        // const controller = new RequestController(2);

        // // 添加请求
        // controller.add(() => mockRequest(1, 1000)).then((result) => console.log(result));
        // controller.add(() => mockRequest(2, 2000)).then((result) => console.log(result));
        // controller.add(() => mockRequest(3, 500)).then((result) => console.log(result));
        // controller.add(() => mockRequest(4, 1500)).then((result) => console.log(result));

        // 移除一个请求（可选）
        // const requestFn = () => mockRequest(5, 1000);
        // controller.add(requestFn).then((result) => console.log(result));
        // controller.remove(requestFn); // 移除未执行的请求


        // Todo: 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
        // 有效字符串需满足：
        // 左括号必须用相同类型的右括号闭合。
        // 左括号必须以正确的顺序闭合。
        // 每个右括号都有一个对应的相同类型的左括号。
        // 示例 1：输入：s = "()"
        // 输出：true
        // 示例 2：
        // 输入：s = "()[]{}"
        // 输出：true
        // 示例 3：
        // 输入：s = "(]"
        // 输出：false
        // 示例 4：
        // 输入：s = "([])"
        // 输出：true

        // 解题核心：1.括号是可以罗列的。不然很难知道括号是否成对。
        //          2. 利用栈的思想来解决。
        // /**
        //  * @param {string} s
        //  * @return {boolean}
        //  */
        // var isValid = function (s) {
        //     let stack = []
        //     const bracketMap = {
        //         '(': ')',
        //         '[': ']',
        //         '{': '}',
        //     };
        //     for (let char of s) {
        //         // char
        //         // 判断当前的字符是否与数组最后一个元素成对，不成对则推入，成对，则删除最后一个元素
        //         if (bracketMap[char]) {
        //             stack.push(char)
        //         } else {
        //             // 右括号
        //             const top = stack.pop()
        //             if (bracketMap[top] !== char) {
        //                 return false
        //             }
        //         }
        //     }
        //     return stack.length === 0
        // };

        // Todo: 全排列
        // 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
        // 示例 1：
        // 输入：nums = [1, 2, 3]
        // 输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
        // 示例 2：
        // 输入：nums = [0, 1]
        // 输出：[[0, 1], [1, 0]]
        // 示例 3：
        // 输入：nums = [1]
        // 输出：[[1]]

        // Tip: 解题思路：使用回溯法，试探每一种可能性，如果已经使用 used 打标了，则continue；
        // 如果没有使用的话，推进 path 里面，继续回溯，
        // 直到，path.length === nums.length，收集结果，然后return
        // 清除 used 标记，并把 path 最后一个元素 pop()，出来，继续下一轮循环

        /**
         * @param {number[]} nums
         * @return {number[][]}
         */
        // function permute(nums) {
        //     let result = [], path = []
        //     function backtracking(list, len, used) {
        //         // 添加终止条件
        //         if (len === path.length) {
        //             console.log('path', path)
        //             // result.push(path)
        //             // Tip: 因为这里的path是一个对象引用，所以需要拷贝 Array.from 其内容结果。
        //             // result.push(Array.from(path))
        //             // result.push(path.slice())
        //             result.push(path.slice())
        //             return;
        //         }
        //         for (let i = 0; i < len; i++) {
        //             if (used[i]) {
        //                 continue
        //             }
        //             used[i] = true
        //             path.push(list[i])
        //             backtracking(list, len, used)
        //             path.pop()
        //             used[i] = false
        //         }
        //     }
        //     backtracking(nums, nums.length, [])
        //     return result
        // }
        // console.log(permute([1, 2, 3]))


        // Todo: 快速排序
        // 核心思想：
        // 基线条件：如果数组长度小于等于 1，直接返回数组，因为已经有序。
        // 选择基准值：通常选择数组的第一个元素作为基准值（pivot）。
        // 分区：遍历数组，将比 pivot 小的元素放入 left 数组，比 pivot 大的元素放入 right 数组。
        // 递归排序：对 left 和 right 数组递归调用 quickSort，然后将结果与 pivot 合并。
        // 返回结果：使用展开运算符 ... 将排序后的 left、pivot 和 right 合并成一个新数组。
        
        // function quickSort(nums) {
        //     if (nums.length <= 1) {
        //         return nums
        //     }
        //     let leftNums = []
        //     let rightNums = []
        //     let baseLine = nums[0]
        //     for (let i = 1; i < nums.length; i++) {
        //         if (nums[i] < baseLine) {
        //             leftNums.push(nums[i])
        //         } else {
        //             rightNums.push(nums[i])
        //         }
        //     }
        //     return [...quickSort(leftNums), baseLine, ...quickSort(rightNums)]
        // }

        // console.log(quickSort([-1, 0, 1, 2, -1, -4]))

        


        




































































    </script>
</body>

</html>