<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hand-review-2</title>
</head>

<body>
    <script>
        // Todo: js反转链表
        // let head = [1, 2, 3, 4, 5]
        // class ListNode {
        //     constructor(value, next) {
        //         this.value = value
        //         this.next = next
        //     }
        // }
        // // 将数组转换为链表
        // function arrayToList(arr) {
        //     if (!arr.length) {
        //         return
        //     }
        //     let head = new ListNode(arr[0])
        //     let current = head
        //     for (let i = 1; i < arr.length; i++) {
        //         let item = arr[i]
        //         current.next = new ListNode(arr[i])
        //         current = current.next
        //     }
        //     return head
        // }
        // // let curr = arrayToList(head)
        // // printList(curr)
        // function reverseList(head) {
        //     let pre = head, curr = null
        //     while (pre) {
        //         let t = pre.next
        //         pre.next = curr
        //         curr = pre
        //         pre = t
        //     }
        //     return curr
        // }
        // let curr = arrayToList(head)
        // printList(reverseList(curr))
        // function ListNode(val, next) {
        //     this.val = (val === undefined ? 0 : val)
        //     this.next = (next === undefined ? null : next)
        // }
        // var reverseList = function (head) {
        //     let temp = new ListNode();
        //     let next = null;
        //     while (head) {
        //         next = head.next;//下一个节点
        //         head.next = temp.next;
        //         temp.next = head;//head接在temp的后面
        //         head = next;//head向后移动一位
        //     }
        //     return temp.next;
        // };
        // let head = [1,2,3,4,5]
        // console.log(reverseList(head))

        // Todo: 数字之和是 N 数字之和的两倍
        // 编写一个js函数 function solution (N);
        // 给定一个整数 N，返回大于 N 的最小整数，其数字之和是 N 数字之和的两倍。
        // 例子:
        // 1.给定 N=14，函数应该返回 19。19 的数字和(1+9=10)是 14 的数字和(1+4=5)的两倍。
        // 2.给定 N=10，该函数应该返回 11。
        // 3.假设 N=99，该函数应该返回 9999。假设:
        // ·N是[1..500]范围内的整数

        // function numSum(num) {
        //     return (num + '').split('').reduce(function name(sum, curr) {
        //         return sum + Number(curr)
        //     }, 0)
        // }

        // function solution(N) {
        //     let result = void 0, isHas = false
        //     for (let i = N; i < 9999; i++) {
        //         if (isHas) return result
        //         if (numSum(i) / numSum(N) == 2) {
        //             result = i
        //             isHas = true
        //         }
        //     }
        //     return result
        // }
        // console.log(solution(14))

        // function sumOfDigits(num) {
        //     // 计算数字的各位数字之和
        //     return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        // }

        // function solution(N) {
        //     const targetSum = sumOfDigits(N) * 2;  // 目标数字之和是 N 数字之和的两倍
        //     let candidate = N + 1;  // 从 N+1 开始查找

        //     // 不断递增查找，直到找到满足条件的数字
        //     while (sumOfDigits(candidate) !== targetSum) {
        //         candidate++;
        //     }

        //     return candidate;  // 返回找到的数字
        // }

        // // 示例测试
        // console.log(solution(14));  // 输出: 19
        // console.log(solution(10));  // 输出: 11
        // console.log(solution(99));  // 输出: 9999


        // Todo: 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
        // 实现 LRUCache 类：
        // LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
        // int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
        // void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；
        // 如果不存在，则向缓存中插入该组 key-value 。
        // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        // 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
        // 输入
        // ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
        // [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

        // 输出
        // [null, null, null, 1, null, -1, null, -1, 3, 4]
        // 解释
        // LRUCache lRUCache = new LRUCache(2);
        // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // lRUCache.get(1);     // 返回 1
        // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // lRUCache.get(2);     // 返回 -1 (未找到)
        // lRUCache.put(4, 4);  // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
        // lRUCache.get(1);     // 返回 -1 (未找到)
        // lRUCache.get(3);     // 返回 3
        // lRUCache.get(4);     // 返回 4

        /**
        * @param {number} capacity
        */
        // var LRUCache = function (capacity) {
        //     this.capacity = capacity;
        //     this.map = new Map();
        // };
        // /** 
        //  * @param {number} key
        //  * @return {number}
        //  */
        // LRUCache.prototype.get = function (key) {
        //     if (this.map.has(key)) {
        //         let val = this.map.get(key)
        //         this.map.delete(key);
        //         this.map.set(key, val); // 放到最前面
        //         return val
        //     } else {
        //         return -1
        //     }
        // };

        // /** 
        //  * @param {number} key 
        //  * @param {number} value
        //  * @return {void}
        //  */
        // LRUCache.prototype.put = function (key, value) {
        //     if (this.map.has(key)) {
        //         this.map.delete(key);
        //     }
        //     this.map.set(key, value);
        //     // 如果超出怎么办？
        //     if (this.map.size > this.capacity) {
        //         // this.map.keys() 返回一个迭代器对象
        //         // next().value
        //         // 返回第一个 key
        //         this.map.delete(this.map.keys().next().value);
        //     }
        // };

        // /**
        //  * Your LRUCache object will be instantiated and called as such:
        //  * var obj = new LRUCache(capacity)
        //  * var param_1 = obj.get(key)
        //  * obj.put(key,value)
        //  */
        // // let lRUCache = new LRUCache(2);
        // // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // // console.log('lRUCache', lRUCache)

        // // console.log(lRUCache.get(1));     // 返回 1
        // // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // // console.log(lRUCache.get(2));     // 返回 -1

        // const myMap = new Map();
        // myMap.set("0", "foo");
        // myMap.set(1, "bar");
        // myMap.set({}, "baz");
        // const mapIter = myMap.keys();
        // console.log(mapIter.next());
        // console.log(mapIter.next().value); // "0"
        // console.log(mapIter.next().value); // 1
        // console.log(mapIter.next().value); // {}

        // Todo:  一个跨域不存在的404请求
        // - [x] 解答：预检请求没有拿到 access-control-allow-origin 相关字段配置(服务器端)，
        // 那么正确的请求会被浏览器 block 掉，并且会报 cors error
        // 使用 Fetch API 发起跨域请求
        // fetch('111', {
        //     method: 'GET', // 或 'POST' 根据实际需要
        //     headers: {
        //         'Content-Type': 'application/json'
        //     },
        //     // 其他可选配置...
        // })
        //     .then(response => response.json()) // 解析 JSON 响应
        //     .then(data => {
        //         console.log('数据:', data);
        //     })
        //     .catch(error => {
        //         console.error('请求失败:', error);
        //     });


        // Todo: 手写 - 如何找到数组中第一个没出现的最小正整数怎么优化（字节）
        // 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
        // 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
        // 示例 1：
        // 输入：nums = [1,2,0]
        // 输出：3

        // 示例 2：
        // 输入：nums = [3,4,-1,1]
        // 输出：2

        // 示例 3：
        // 输入：nums = [7,8,9,11,12]
        // 输出：1
        // 算法题

        // 思路：前后差值是1说明连续，
        // 1, 2, 4
        // function getMinNumNoShow (arr) {
        //   let minNum = null
        //   let list = arr.filter(item => item > 0).sort()
        //   for (let i = 0; i < list.length; i++) {
        //     const current = list[i]
        //     const next = list[i+1]
        //     if (i == 0 && 1 != current) {
        //       minNum = 1
        //       break
        //     }
        //     if ((current && next && (next - current) > 1) || !next) {
        //       minNum = current + 1
        //       break
        //     }
        //   }
        //   return minNum
        // }
        // const nums = [1,2,0]
        // const nums = [7,8,9,11,12]
        // const nums = [3,4,-1,1]
        // console.log(getMinNumNoShow(nums))
        // 算法复杂度如何计算 O(3n)
        // 一次循环搞定
        // Why O(n)


        // Todo: 手写-怎么在指定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）
        // const testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
        // const n = 5
        // // => [1, 2, 3, 4, 5, 6]
        // function getArrByParams (arr, n) {
        //   let result = []
        //   for (let i = 0; i < arr.length; i++) {
        //     const element = arr[i];
        //     if (result.indexOf(element) == -1) {
        //       result.push(element)
        //       if (result.length == n) {
        //         break;
        //       }
        //     }
        //   }
        //   return result
        // }
        // console.log(getArrByParams(testArray, n))
        // 算法复杂度
        // Why O(n)


        // Todo: 三数之和
        // 给你一个整数数组 nums ，判断是否存在三元组[nums[i], nums[j], nums[k]] 
        // 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。
        // 请你返回所有和为 0 且不重复的三元组。
        // 注意：答案中不可以包含重复的三元组。

        // function threeSum(nums) {
        //     const res = [];
        //     const n = nums.length;
        //     // 三层循环遍历
        //     for (let i = 0; i < n - 2; i++) {
        //         for (let j = i + 1; j < n - 1; j++) {
        //             for (let k = j + 1; k < n; k++) {
        //                 // 检查和是否为 0
        //                 if (nums[i] + nums[j] + nums[k] === 0) {
        //                     // 将三元组添加到结果中
        //                     const triplet = [nums[i], nums[j], nums[k]];
        //                     // 防止添加重复的三元组
        //                     // Tip: 这个判断不能保证组合内部元素不重复，如果 nums 有重复的元素的话，有几率产生重复的组合。
        //                     if (!res.some(item =>
        //                         item[0] === triplet[0] && item[1] === triplet[1] && item[2] === triplet[2]
        //                     )) {
        //                         res.push(triplet);
        //                     }
        //                 }
        //             }
        //         }
        //     }
        //     return res;
        // }
        // // 示例
        // console.log(threeSum([-1, 0, 1, 2, -1, -4]));

        // Todo: 第一种解法：三层 for 循环暴力破解
        // function threeSum(nums) {
        //     const result = [];
        //     const n = nums.length;
        //     // 先对数组排序，方便去重，从小到大排序
        //     nums.sort((a, b) => a - b);
        //     // 三层循环暴力枚举
        //     for (let i = 0; i < n - 2; i++) {
        //         // 跳过重复的 a
        //         // 为什么这样就可以跳过呢？
        //         if (i > 0 && nums[i] === nums[i - 1]) continue;
        // 
        //         for (let j = i + 1; j < n - 1; j++) {
        //             // 关注起始位的索引参数
        //             // 跳过重复的 b
        //             if (j > i + 1 && nums[j] === nums[j - 1]) continue;
        //             // 保证索引大于前一个，并且两两不相同即可保证
        //             for (let k = j + 1; k < n; k++) {
        //                 // 跳过重复的 c
        //                 if (k > j + 1 && nums[k] === nums[k - 1]) continue;
        //                 // 检查是否满足 a + b + c = 0
        //                 if (nums[i] + nums[j] + nums[k] === 0) {
        //                     result.push([nums[i], nums[j], nums[k]]);
        //                 }
        //             }
        //         }
        //     }
        //     return result;
        // }
        // // 示例
        // const nums = [-1, 0, 1, 2, -1, -4];
        // const result = threeSum(nums);
        // console.log(result); // 输出: [[-1, -1, 2], [-1, 0, 1]]

        // 第二种：双指针索引法
        // 
        // function threeSum(nums) {
        //     const result = [];
        //     const n = nums.length;
        //     // 先对数组排序
        //     nums.sort((a, b) => a - b);

        //     // 遍历数组，固定 a
        //     for (let i = 0; i < n - 2; i++) {
        //         // 跳过重复的 a
        //         // 因为数组已经排序过了，所以只要判断相邻两两不相同，
        //         // 即可保证，当前三元组的第一个元素是不重复的
        //         if (i > 0 && nums[i] === nums[i - 1]) continue;
        //         // 初始化双指针
        //         let left = i + 1;
        //         let right = n - 1;
        //         // 双指针寻找 b 和 c
        //         while (left < right) {
        //             const sum = nums[i] + nums[left] + nums[right];
        //             if (sum < 0) {
        //                 left++; // 和太小，左指针右移
        //             } else if (sum > 0) {
        //                 right--; // 和太大，右指针左移
        //             } else {
        //                 // 找到满足条件的三元组
        //                 result.push([nums[i], nums[left], nums[right]]);
        //                 // 跳过重复的 b 和 c
        //                 while (left < right && nums[left] === nums[left + 1]) {
        //                     left++;
        //                 }
        //                 while (left < right && nums[right] === nums[right - 1]) {
        //                     right--;
        //                 }
        //                 // 移动指针
        //                 left++;
        //                 right--;
        //             }
        //         }
        //     }

        //     return result;
        // }

        // // 示例
        // const nums = [-1, 0, 1, 2, -1, -4];
        // const result = threeSum(nums);
        // console.log(result); // 输出: [[-1, -1, 2], [-1, 0, 1]]


        // Todo: 数组中的第K个最大元素
        // 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
        // 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
        // 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 如何使用大顶堆解决问题呢？

        // function solution(nums, k) {
        //     nums.sort((a, b) => b - a)
        //     return nums[k - 1]
        // }


        // Todo: 最大子数组和
        // 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），
        // 返回其最大和。子数组是数组中的一个连续部分。

        // var maxSubArray = function (nums) {
        //     let len = nums.length, maxSum = 0
        //         , begin = 0, end = 0;
        //     for (let i = 0; i < len; i++) {
        //         if (len == 1) {
        //             return nums[0]
        //         }
        //         for (let j = 1; j < len; j++) {
        //             if (j > i) {
        //                 // debugger
        //                 let vaildNums = nums.slice(i, j + 1)
        //                 let sum = vaildNums.reduce(
        //                     function (sum, num) {
        //                         return sum + num
        //                     }
        //                 )
        //                 maxSum = Math.max(maxSum, sum)
        //             }
        //         }
        //     }
        //     return maxSum;
        // };

        function maxSubArray(nums) {
            let preSum = 0, maxSum = nums[0] //Tip: 假定第一个最大
            nums.forEach(num => {
                preSum = Math.max(preSum + num, num)
                maxSum = Math.max(maxSum, preSum)
            });
            return maxSum
        }

        console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))
        console.log(maxSubArray([1]))
        console.log(maxSubArray([5, 4, -1, 7, 8]))































    </script>
</body>

</html>