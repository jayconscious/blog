<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hand-review-2</title>
</head>

<body>
    <script>
        // Todo: js反转链表
        // let head = [1, 2, 3, 4, 5]
        // class ListNode {
        //     constructor(value, next) {
        //         this.value = value
        //         this.next = next
        //     }
        // }
        // // 将数组转换为链表
        // function arrayToList(arr) {
        //     if (!arr.length) {
        //         return
        //     }
        //     let head = new ListNode(arr[0])
        //     let current = head
        //     for (let i = 1; i < arr.length; i++) {
        //         let item = arr[i]
        //         current.next = new ListNode(arr[i])
        //         current = current.next
        //     }
        //     return head
        // }
        // // let curr = arrayToList(head)
        // // printList(curr)
        // function reverseList(head) {
        //     let pre = head, curr = null
        //     while (pre) {
        //         let t = pre.next
        //         pre.next = curr
        //         curr = pre
        //         pre = t
        //     }
        //     return curr
        // }
        // let curr = arrayToList(head)
        // printList(reverseList(curr))
        // function ListNode(val, next) {
        //     this.val = (val === undefined ? 0 : val)
        //     this.next = (next === undefined ? null : next)
        // }
        // var reverseList = function (head) {
        //     let temp = new ListNode();
        //     let next = null;
        //     while (head) {
        //         next = head.next;//下一个节点
        //         head.next = temp.next;
        //         temp.next = head;//head接在temp的后面
        //         head = next;//head向后移动一位
        //     }
        //     return temp.next;
        // };
        // let head = [1,2,3,4,5]
        // console.log(reverseList(head))

        // Todo: 数字之和是 N 数字之和的两倍
        // 编写一个js函数 function solution (N);
        // 给定一个整数 N，返回大于 N 的最小整数，其数字之和是 N 数字之和的两倍。
        // 例子:
        // 1.给定 N=14，函数应该返回 19。19 的数字和(1+9=10)是 14 的数字和(1+4=5)的两倍。
        // 2.给定 N=10，该函数应该返回 11。
        // 3.假设 N=99，该函数应该返回 9999。假设:
        // ·N是[1..500]范围内的整数

        // function numSum(num) {
        //     return (num + '').split('').reduce(function name(sum, curr) {
        //         return sum + Number(curr)
        //     }, 0)
        // }

        // function solution(N) {
        //     let result = void 0, isHas = false
        //     for (let i = N; i < 9999; i++) {
        //         if (isHas) return result
        //         if (numSum(i) / numSum(N) == 2) {
        //             result = i
        //             isHas = true
        //         }
        //     }
        //     return result
        // }
        // console.log(solution(14))

        // function sumOfDigits(num) {
        //     // 计算数字的各位数字之和
        //     return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        // }

        // function solution(N) {
        //     const targetSum = sumOfDigits(N) * 2;  // 目标数字之和是 N 数字之和的两倍
        //     let candidate = N + 1;  // 从 N+1 开始查找

        //     // 不断递增查找，直到找到满足条件的数字
        //     while (sumOfDigits(candidate) !== targetSum) {
        //         candidate++;
        //     }

        //     return candidate;  // 返回找到的数字
        // }

        // // 示例测试
        // console.log(solution(14));  // 输出: 19
        // console.log(solution(10));  // 输出: 11
        // console.log(solution(99));  // 输出: 9999


        // Todo: 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
        // 实现 LRUCache 类：
        // LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
        // int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
        // void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；
        // 如果不存在，则向缓存中插入该组 key-value 。
        // 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        // 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
        // 输入
        // ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
        // [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

        // 输出
        // [null, null, null, 1, null, -1, null, -1, 3, 4]
        // 解释
        // LRUCache lRUCache = new LRUCache(2);
        // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // lRUCache.get(1);     // 返回 1
        // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // lRUCache.get(2);     // 返回 -1 (未找到)
        // lRUCache.put(4, 4);  // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
        // lRUCache.get(1);     // 返回 -1 (未找到)
        // lRUCache.get(3);     // 返回 3
        // lRUCache.get(4);     // 返回 4

        /**
        * @param {number} capacity
        */
        // var LRUCache = function (capacity) {
        //     this.capacity = capacity;
        //     this.map = new Map();
        // };
        // /** 
        //  * @param {number} key
        //  * @return {number}
        //  */
        // LRUCache.prototype.get = function (key) {
        //     if (this.map.has(key)) {
        //         let val = this.map.get(key)
        //         this.map.delete(key);
        //         this.map.set(key, val); // 放到最前面
        //         return val
        //     } else {
        //         return -1
        //     }
        // };

        // /** 
        //  * @param {number} key 
        //  * @param {number} value
        //  * @return {void}
        //  */
        // LRUCache.prototype.put = function (key, value) {
        //     if (this.map.has(key)) {
        //         this.map.delete(key);
        //     }
        //     this.map.set(key, value);
        //     // 如果超出怎么办？
        //     if (this.map.size > this.capacity) {
        //         // this.map.keys() 返回一个迭代器对象
        //         // next().value
        //         // 返回第一个 key
        //         this.map.delete(this.map.keys().next().value);
        //     }
        // };

        // /**
        //  * Your LRUCache object will be instantiated and called as such:
        //  * var obj = new LRUCache(capacity)
        //  * var param_1 = obj.get(key)
        //  * obj.put(key,value)
        //  */
        // // let lRUCache = new LRUCache(2);
        // // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // // console.log('lRUCache', lRUCache)

        // // console.log(lRUCache.get(1));     // 返回 1
        // // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // // console.log(lRUCache.get(2));     // 返回 -1

        // const myMap = new Map();
        // myMap.set("0", "foo");
        // myMap.set(1, "bar");
        // myMap.set({}, "baz");
        // const mapIter = myMap.keys();
        // console.log(mapIter.next());
        // console.log(mapIter.next().value); // "0"
        // console.log(mapIter.next().value); // 1
        // console.log(mapIter.next().value); // {}

        // Todo:  一个跨域不存在的404请求
        // - [x] 解答：预检请求没有拿到 access-control-allow-origin 相关字段配置(服务器端)，
        // 那么正确的请求会被浏览器 block 掉，并且会报 cors error
        // 使用 Fetch API 发起跨域请求
        // fetch('111', {
        //     method: 'GET', // 或 'POST' 根据实际需要
        //     headers: {
        //         'Content-Type': 'application/json'
        //     },
        //     // 其他可选配置...
        // })
        //     .then(response => response.json()) // 解析 JSON 响应
        //     .then(data => {
        //         console.log('数据:', data);
        //     })
        //     .catch(error => {
        //         console.error('请求失败:', error);
        //     });


          // Todo: 手写 - 如何找到数组中第一个没出现的最小正整数怎么优化（字节）
    // 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
    // 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
    // 示例 1：
    // 输入：nums = [1,2,0]
    // 输出：3

    // 示例 2：
    // 输入：nums = [3,4,-1,1]
    // 输出：2

    // 示例 3：
    // 输入：nums = [7,8,9,11,12]
    // 输出：1
    // 算法题
    
    // 思路：前后差值是1说明连续，
    // 1, 2, 4
    // function getMinNumNoShow (arr) {
    //   let minNum = null
    //   let list = arr.filter(item => item > 0).sort()
    //   for (let i = 0; i < list.length; i++) {
    //     const current = list[i]
    //     const next = list[i+1]
    //     if (i == 0 && 1 != current) {
    //       minNum = 1
    //       break
    //     }
    //     if ((current && next && (next - current) > 1) || !next) {
    //       minNum = current + 1
    //       break
    //     }
    //   }
    //   return minNum
    // }
    // const nums = [1,2,0]
    // const nums = [7,8,9,11,12]
    // const nums = [3,4,-1,1]
    // console.log(getMinNumNoShow(nums))
    // 算法复杂度如何计算 O(3n)
    // 一次循环搞定
    // Why O(n)


    // Todo: 手写-怎么在指定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）
    // const testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    // const n = 5
    // // => [1, 2, 3, 4, 5, 6]
    // function getArrByParams (arr, n) {
    //   let result = []
    //   for (let i = 0; i < arr.length; i++) {
    //     const element = arr[i];
    //     if (result.indexOf(element) == -1) {
    //       result.push(element)
    //       if (result.length == n) {
    //         break;
    //       }
    //     }
    //   }
    //   return result
    // }
    // console.log(getArrByParams(testArray, n))
    // 算法复杂度
    // Why O(n)


        // Todo: 数组中的第K个最大元素
        // 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
        // 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
        // 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 如何使用大顶堆解决问题呢？
























    </script>
</body>

</html>