<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Todo: 最长回文串
        // 方法三：中心扩展法（最优解）
        // 思路：以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。
        // 时间复杂度：O(n²)。
        // 空间复杂度：O(1)。
        // function longestPalindrome(s) {
        //     let max = '';
        //     for (let i = 0; i < s.length; i++) {
        //         // 奇数长度回文（以s[i]为中心）
        //         const odd = expandAroundCenter(s, i, i);
        //         // 偶数长度回文（以s[i]和s[i+1]为中心）
        //         const even = expandAroundCenter(s, i, i + 1);
        //         // 更新最大值
        //         if (odd.length > max.length) max = odd;
        //         if (even.length > max.length) max = even;
        //     }
        //     return max;
        // }
        // function expandAroundCenter(s, left, right) {
        //     while (left >= 0 && right < s.length && s[left] === s[right]) {
        //         left--;
        //         right++;
        //     }
        //     return s.slice(left + 1, right); // 注意边界
        // }
        // console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"


        // Todo: 质数因子
        // 180
        // function solution(num) {
        //     let res = [];
        //     let i = 2;
        //     while (i <= num && i * i <= num) {
        //         if (num % i === 0) {
        //             res.push(i);
        //             num = num / i;
        //             i = 2;
        //         } else {
        //             i++
        //         }
        //     }
        //     if (num !== 1) {
        //         res.push(i)
        //     }
        //     return res.join(' ');
        // }
        // console.log(solution(180))

        // let floatNum = readline();
        // let res = parseFloat(floatNum).toFixed(0)
        // console.log(res)


        // Todo: b是否是a的子集
        // a和b有重复元素，要求b的同个元素出现次数<=a的同个元素出现次数

        // function isSubset(a, b) {
        //     // 统计a中每个元素的出现次数
        //     const frequencyMap = {};
        //     for (const elem of a) {
        //         frequencyMap[elem] = frequencyMap[elem] ? frequencyMap[elem] + 1 : 1;
        //     }

        //     // 检查b中的每个元素是否都在a中且出现次数不超过
        //     for (const elem of b) {
        //         if (!frequencyMap[elem]) {
        //             return false;  // 元素不存在于a中
        //         }
        //         frequencyMap[elem]--;
        //         if (frequencyMap[elem] < 0) {
        //             return false;  // 元素出现次数超过a中的次数
        //         }
        //     }

        //     return true;
        // }

        // // 示例
        // const a = [1, 2, 2, 3, 4];
        // const b1 = [2, 2];  // 是子集
        // const b2 = [2, 2, 2];  // 不是子集（2出现3次 > a中的2次）

        // console.log(isSubset(a, b1)); // true
        // console.log(isSubset(a, b2)); // false

        // Todo: 将一串数组节点转化为二叉树

        // function TreeNode(val, left, right) {
        //     this.val = (val === undefined ? 0 : val);
        //     this.left = (left === undefined ? null : left);
        //     this.right = (right === undefined ? null : right);
        // }
        // function arrayToTree(arr, index = 0) {
        //     if (index >= arr.length || arr[index] === null) {
        //         return null;
        //     }
        //     const node = new TreeNode(arr[index]);
        //     node.left = arrayToTree(arr, 2 * index + 1);  // 左子节点索引
        //     node.right = arrayToTree(arr, 2 * index + 2); // 右子节点索引
        //     return node;
        // }

        // const arr = [1, 2, 3, 4, 5, 6, 7];
        // const root = arrayToTree(arr);
        // console.log(root);

        // Todo: 二叉树层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你二叉树的根节点 root ，返回其节点值的层序遍历 。 （即逐层地，从左到右访问所有节点）。
        // 输入：root = [3,9,20,null,null,15,7]
        // 输出：[[3],[9,20],[15,7]]
        // 示例 2：
        // 输入：root = [1]
        // 输出：[[1]]
        // 广度优先遍历

        // let root = arrayToTree([3, 9, 20, null, null, 15, 7])

        // // console.log('root', root)

        // var levelOrder = function (root) {
        //     //二叉树的层序遍历
        //     let res = [], queue = [];
        //     queue.push(root);
        //     if (root === null) {
        //         return res;
        //     }
        //     while (queue.length !== 0) {
        //         // 记录当前层级节点数
        //         let length = queue.length;
        //         //存放每一层的节点 
        //         let curLevel = [];
        //         for (let i = 0; i < length; i++) {
        //             let node = queue.shift(); // 取节点，存值，
        //             curLevel.push(node.val);
        //             // 存放当前层下一层的节点
        //             node.left && queue.push(node.left);
        //             node.right && queue.push(node.right);
        //         }
        //         //把每一层的结果放到结果数组
        //         res.push(curLevel);
        //     }
        //     return res;
        // };

        // console.log(levelOrder(root))

        // // Todo: 输出二叉树的非子叶节点
        // // 深度优先搜索（DFS）递归
        // function getNonLeafNodesDFS(root) {
        //     let nonLeafNodes = []
        //     function dfs(rootNode) {
        //         if (rootNode == null) return
        //         if (rootNode.left || rootNode.right) {
        //             res.push(rootNode.val)
        //         }
        //         dfs(rootNode.left)
        //         dfs(rootNode.right)
        //     }
        //     dfs(root)
        //     return nonLeafNodes
        // }

        // function getNonLeafNodesBFS(root) {
        //     if (!root) return [];
        //     const nonLeafNodes = [];
        //     const queue = [root];
        //     while (queue.length) {
        //         const node = queue.shift();
        //         if (node.left || node.right) {
        //             nonLeafNodes.push(node.val);
        //         }
        //         if (node.left) queue.push(node.left);
        //         if (node.right) queue.push(node.right);
        //     }
        //     return nonLeafNodes;
        // }


        // Todo: 接雨水问题
        // https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked
        // 双指针索引法
        // 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
        // 示例 1：
        // 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
        // 输出：6
        // 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

        // function solution(list) {
        //     let res = 0, left = 0, right = list.length - 1, leftMax = 0, rightMax = 0;
        //     while (left < right) {
        //         if (list[left] < list[right]) {
        //             if (list[left] > leftMax) {
        //                 leftMax = list[left]
        //             } else {
        //                 let currGap = leftMax - list[left]
        //                 res += currGap
        //             }
        //             left++
        //         } else {
        //             if (list[right] > rightMax) {
        //                 rightMax = list[right]
        //             } else {
        //                 let currGap = rightMax - list[right]
        //                 res += currGap
        //             }
        //             right--
        //         }
        //     }
        //     return res
        // }

        // console.log(solution([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))


        // Todo: 136. 只出现一次的数字
        // 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
        // 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
        // https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked
        /**
         * @param {number[]} nums
         * @return {number}
         */

        // var singleNumber = function (nums) {
        //     let res = null
        //     let map = Object.create(null)
        //     nums.forEach(num => {
        //         if (map[num]) {
        //             item = map[num]
        //             item.count = item.count + 1
        //         } else {
        //             map[num] = {
        //                 count: 1,
        //                 val: num
        //             }
        //         }
        //     })
        //     console.log('map', map)
        //     Object.values(map).forEach(obj => {
        //         if (obj.count == 1) {
        //             res = obj.val
        //         }
        //     })
        //     return res

        // };

        // // Todo: 解题核心其余每一个元素都出现 2 次，多了也不行
        // var singleNumber = function (nums) {
        //     let ans = 0;
        //     for (const num of nums) {
        //         ans ^= num;
        //     }
        //     return ans;
        // };
        // console.log(singleNumber([4, 1, 2, 1, 2]))

        // // Todo: 二叉树中序续遍历 左 -> 根 -> 右
        // var inorderTraversal = function (root) {
        //     const res = [];
        //     const inorder = (root) => {
        //         if (!root) {
        //             return;
        //         }
        //         inorder(root.left);
        //         res.push(root.val);
        //         inorder(root.right);
        //     }
        //     inorder(root);
        //     return res;
        // };


        // Todo: 杨辉三角问题 - 字节面试题
        // https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked
        // 方法一：
        // function solution(numRows) {
        //     let res = []
        //     for (let i = 0; i < numRows; i++) {
        //         let currentArr = new Array(i + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[i - 1][j - 1] + res[i - 1][j];
        //         }
        //         res.push(currentArr)
        //     }
        //     return res;
        // }

        // 方法二：
        // function solution(numRows) {
        //     let res = [], initRow = 0;
        //     function inner(currentRow) {
        //         if (currentRow == numRows) {
        //             return
        //         }
        //         let currentArr = new Array(currentRow + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[currentRow - 1][j - 1] + res[currentRow - 1][j]
        //         }
        //         res.push(currentArr)
        //         currentRow += 1
        //         inner(currentRow)
        //     }
        //     inner(initRow)
        //     return res
        // }
        // console.log(solution(5))


        // Todo: - 字节面试题
        // * 已知有一
        // *@param a
        // * @param b
        // * @returns
        // async function addRemote(a: number, b: number) {await new Promise((resolve)=>setTimeout(resolveMath.random()* 100));
        // return a + b;
        // 米米
        // *请实现本地的 add 方法，调用 addRemote，能最优的实现输入数字的加法。
        // *@example
        // * add(5,6).then(result =>{
        // console.log(result); // 11
        // *});
        // * add(1, 4,3, 3, 5).then(result =>{
        // *console.log(result); // 16
        // *})
        // *add(2,3,3,3,4,1, 3, 3, 5).then(result =>{
        // console.log(result); // 27
        // *})
        // Promise<number> 
        // async function add(...inputs) {// 你的实现
        // }

        // Todo: 最长连续序列
        // https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
        // 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 示例 1：
        // 输入：nums = [100,4,200,1,3,2]
        // 输出：4
        // 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

        // 示例 2：
        // 输入：nums = [0,3,7,2,5,8,4,6,0,1]
        // 输出：9

        // 示例 3：
        // 输入：nums = [1,0,1,2]
        // 输出：3

        // 不行
        // function solution(nums) {
        //     let res = [], start = 0, max = 0
        //     nums.sort((a, b) => a - b)
        //     for (let i = 0; i < nums.length; i++) {
        //         const element = nums[i]
        //         if (element + 1 == nums[i + 1]) {
        //             // 连续
        //         } else if (element == nums[i + 1]) {
        //             // 相同
        //             start = i + 1
        //         } else {
        //             // 不连续
        //             let arr = [...nums].slice(start, i + 1)
        //             max = Math.max(max, arr.length)
        //             start = i + 1
        //         }
        //     }
        //     return max
        // }

        // var longestConsecutive = function (nums) {
        //     let ans = 0;
        //     const st = new Set(nums); // 把 nums 转成哈希集合
        //     for (const x of st) { // 遍历哈希集合
        //         if (st.has(x - 1)) {
        //             continue;
        //         }
        //         // x 是序列的起点
        //         let y = x + 1;
        //         while (st.has(y)) { // 不断查找下一个数是否在哈希集合中
        //             y++;
        //         }
        //         // 循环结束后，y-1 是最后一个在哈希集合中的数
        //         ans = Math.max(ans, y - x); // 从 x 到 y-1 一共 y-x 个数
        //     }
        //     return ans;
        // };

        // console.log(solution([100, 4, 200, 1, 3, 2]))


        // Todo: 移动零
        // https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
        // 请注意 ，必须在不复制数组的情况下原地对数组进行操作。
        // 示例 1:
        // 输入: nums = [0,1,0,3,12]
        // 输出: [1,3,12,0,0]

        // 示例 2:
        // 输入: nums = [0]
        // 输出: [0]

        // function solution(nums) {
        //     let res = [], zoreList = []
        //     nums.forEach((item) => {
        //         if (item == 0) {
        //             zoreList.push(item)
        //         } else {
        //             res.push(item)
        //         }
        //     })
        //     return res.sort((a, b) => a - b).concat(zoreList)
        // }

        // var moveZeroes = function (nums) {
        //     let slow = 0
        //     for (let fast = 0; fast < nums.length; fast++) {
        //         if (nums[fast] !== 0) {
        //             nums[slow] = nums[fast]
        //             slow++
        //         }
        //     }
        //     nums.fill(0, slow)
        //     return nums
        // };

        // console.log(moveZeroes([0, 1, 0, 3, 12]))

        // function solution(nums) {
        //     let slow = 0
        //     for (let right = 0; right < nums.length; right++) {
        //         if (nums[right] != 0) {
        //             nums[slow] = nums[right]
        //             slow++
        //         }
        //     }
        //     nums.fill(0, slow)
        //     return nums
        // }

        // Todo: 矩阵置零
        // https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        /**
         * @param {number[][]} matrix
         * @return {void} Do not return anything, modify matrix in-place instead.
         */
        // 解题思路，先标记 0 的下标，然后转化问题，在 matrix 里面只要有一个下标符合，就置为 0 
        // var setZeroes = function (matrix) {
        //     // 记录 m 和 n
        //     const m = matrix.length, n = matrix[0].length
        //     const row = new Array(m).fill(false)
        //     const col = new Array(n).fill(false)
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }
        //     return matrix
        // };

        // Todo: 合并区间
        // https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
        // 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。
        // 请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
        // 示例 1：
        // 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
        // 输出：[[1,6],[8,10],[15,18]]
        // 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

        // 示例 2：
        // 输入：intervals = [[1,4],[4,5]]
        // 输出：[[1,5]]
        // 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
        // 解析思路是啥：
        // Tip: 注意点在于：每一个区间只有两个元素，不会存在多个元素的情况。

        // var merge = function (intervals) {
        //     intervals.sort((a, b) => a[0] - b[0]); // 区间左端点排序，从小到大
        //     // console.log('sort intervals', intervals.slice())
        //     const merged = [];
        //     let i = -1;
        //     intervals.forEach((range) => {
        //         const [start, end] = range;
        //         const [preStart, preEnd] = merged[i] ?? [];
        //         if (merged.length === 0 || (start > preEnd)) {
        //             merged.push(range);
        //             i += 1;
        //         } else if (end > preEnd) {
        //             merged[i][1] = end;
        //         }
        //     });
        //     return merged;
        // }
        // // console.log(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))
        // console.log(merge([[4, 5], [1, 4]]))


        // Todo: 矩阵置零
        // 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        // 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
        // 输出：[[1,0,1],[0,0,0],[1,0,1]]
        // 解题思路：
        // 1. 使用 m, n 长度的数组，标记元素 0 的，假如 matrix[1][1] = 0, 则 m[1] = n[1] = true
        // 2. 遍历嵌套遍历，m，n，m[1]，n[1]

        // function solution(matrix) {
        //     let m = matrix.length
        //     let n = matrix[0].length

        //     let row = new Array(m).fill(false)
        //     let col = new Array(n).fill(false)

        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //                 // 标记位置
        //             }
        //         }
        //     }

        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }

        //     return matrix
        // }

        // var setZeroes = function (matrix) {
        //     // 记录 m 和 n
        //     const m = matrix.length, n = matrix[0].length
        //     const row = new Array(m).fill(false)
        //     const col = new Array(n).fill(false)
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }
        //     return matrix
        // };

        // console.log(solution([[1,1,1],[1,0,1],[1,1,1]]))
        // console.log(setZeroes([[1,1,1],[1,0,1],[1,1,1]]))

        // Todo: 对象扁平化 flatten
        // 解题思路：递归判断 val 的类型，如果是对象或者数组，则继续遍历，将keyPath链接，否则
        // output[keyPath] = val, 挂在输出对象返回。
        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }
        // flatten(obj) 结果返回如下
        // {
        //  'a.b': 1,
        //  'a.c': 2,
        //  'a.d.e': 5,
        //  'b[0]': 1,
        //  'b[1]': 3,
        //  'b[2].a': 2,
        //  'b[2].b': 3
        //   c: 3
        // }

        // 类型判断
        // function getTepy(obj) {
        //     return Object.prototype.toString.call(obj).slice(8, -1)
        // }
        // function objectFlatten(Obj) {
        //     if (getTepy(Obj) != 'Object') {
        //         return
        //     }
        //     let output = {}
        //     function inner(source, keyPath) {
        //         if (getTepy(source) == 'Object') {
        //             for (const key in source) {
        //                 if (Object.prototype.hasOwnProperty.call(source, key)) {
        //                     let nextKeyPath = keyPath ? `${keyPath}.${key}` : `${key}`
        //                     inner(source[key], nextKeyPath)
        //                 }
        //             }
        //         } else if (getTepy(source) == 'Array') {
        //             source.forEach((item, index) => {
        //                 let nextKeyPath = `${keyPath}.[${index}]`
        //                 inner(item, nextKeyPath)
        //             });
        //         } else {
        //             output[keyPath] = source
        //         }
        //     }
        //     inner(Obj, '')
        //     return output
        // }
        // console.log(objectFlatten(obj))

        // Todo: 对象扁平化 flattenRecovery()
        // const source = {
        //     'a.b': 1,
        //     'a.c': 2,
        //     'a.d.e': 5,
        //     'b[0]': 1,
        //     'b[1]': 3,
        //     'b[2].a': 2,
        //     'b[2].b': 3,
        //     'c': 3
        // }

        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }

        // function transformObject(sourceObj) {
        //     let result = {}
        //     Object.keys(sourceObj).forEach((key) => {
        //         const reg = /[\.\[\]]+/
        //         const keyList = key.split(reg).filter(Boolean)
        //         // console.log('keyList', keyList)
        //         let currentLevel = result
        //         for (let i = 0; i < keyList.length; i++) {
        //             const value = sourceObj[key]
        //             const currentPath = keyList[i]
        //             // 判断 i 索引的位置
        //             if (i < keyList.length - 1) {
        //                 if (currentLevel[currentPath] == undefined) {
        //                     currentLevel[currentPath] = isNaN(Number(keyList[i + 1])) ? {} : []
        //                 }
        //             } else if (i = keyList.length - 1) {
        //                 currentLevel[currentPath] = value
        //             }
        //             currentLevel = currentLevel[currentPath]
        //         }
        //     })
        //     return result
        // }
        // console.log(transformObject(source))

        // function getValueByPath(sourceObj, pathStr, defaultValue) {
        //     const reg = /[\.\[\]]+/
        //     const paths = pathStr.split(reg).filter(Boolean)
        //     for (let i = 0; i < paths.length; i++) {
        //         // 判断 path 是字符串还是数字
        //         const currentPath = isNaN(Number(paths[i])) ? paths[i] : Number(paths[i])
        //         if (Object.prototype.hasOwnProperty.call(sourceObj, currentPath)) {
        //             let currentValue = sourceObj[currentPath]
        //             if (currentValue === undefined) {
        //                 return defaultValue
        //             } else {
        //                 if (i < paths.length - 1) {
        //                     sourceObj = currentValue
        //                 } else if (i == paths.length - 1) {
        //                     return currentValue
        //                 }
        //             }
        //         }
        //     }
        // }

        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }
        // // b[2].a
        // console.log(getValueByPath(obj, 'b[2].a'))

        




























































    </script>

</body>

</html>