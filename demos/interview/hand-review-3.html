<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Todo: 最长回文串
        // 方法三：中心扩展法（最优解）
        // 思路：以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。
        // 时间复杂度：O(n²)。
        // 空间复杂度：O(1)。
        // function longestPalindrome(s) {
        //     let max = '';
        //     for (let i = 0; i < s.length; i++) {
        //         // 奇数长度回文（以s[i]为中心）
        //         const odd = expandAroundCenter(s, i, i);
        //         // 偶数长度回文（以s[i]和s[i+1]为中心）
        //         const even = expandAroundCenter(s, i, i + 1);
        //         // 更新最大值
        //         if (odd.length > max.length) max = odd;
        //         if (even.length > max.length) max = even;
        //     }
        //     return max;
        // }
        // function expandAroundCenter(s, left, right) {
        //     while (left >= 0 && right < s.length && s[left] === s[right]) {
        //         left--;
        //         right++;
        //     }
        //     return s.slice(left + 1, right); // 注意边界
        // }
        // console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"


        // Todo: 质数因子
        // 180
        // function solution(num) {
        //     let res = [];
        //     let i = 2;
        //     while (i <= num && i * i <= num) {
        //         if (num % i === 0) {
        //             res.push(i);
        //             num = num / i;
        //             i = 2;
        //         } else {
        //             i++
        //         }
        //     }
        //     if (num !== 1) {
        //         res.push(i)
        //     }
        //     return res.join(' ');
        // }
        // console.log(solution(180))

        // let floatNum = readline();
        // let res = parseFloat(floatNum).toFixed(0)
        // console.log(res)


        // Todo: b是否是a的子集
        // a和b有重复元素，要求b的同个元素出现次数<=a的同个元素出现次数

        // function isSubset(a, b) {
        //     // 统计a中每个元素的出现次数
        //     const frequencyMap = {};
        //     for (const elem of a) {
        //         frequencyMap[elem] = frequencyMap[elem] ? frequencyMap[elem] + 1 : 1;
        //     }

        //     // 检查b中的每个元素是否都在a中且出现次数不超过
        //     for (const elem of b) {
        //         if (!frequencyMap[elem]) {
        //             return false;  // 元素不存在于a中
        //         }
        //         frequencyMap[elem]--;
        //         if (frequencyMap[elem] < 0) {
        //             return false;  // 元素出现次数超过a中的次数
        //         }
        //     }

        //     return true;
        // }

        // // 示例
        // const a = [1, 2, 2, 3, 4];
        // const b1 = [2, 2];  // 是子集
        // const b2 = [2, 2, 2];  // 不是子集（2出现3次 > a中的2次）

        // console.log(isSubset(a, b1)); // true
        // console.log(isSubset(a, b2)); // false

        // Todo: 将一串数组节点转化为二叉树

        // function TreeNode(val, left, right) {
        //     this.val = (val === undefined ? 0 : val);
        //     this.left = (left === undefined ? null : left);
        //     this.right = (right === undefined ? null : right);
        // }
        // function arrayToTree(arr, index = 0) {
        //     if (index >= arr.length || arr[index] === null) {
        //         return null;
        //     }
        //     const node = new TreeNode(arr[index]);
        //     node.left = arrayToTree(arr, 2 * index + 1);  // 左子节点索引
        //     node.right = arrayToTree(arr, 2 * index + 2); // 右子节点索引
        //     return node;
        // }

        // const arr = [1, 2, 3, 4, 5, 6, 7];
        // const root = arrayToTree(arr);
        // console.log(root);

        // Todo: 二叉树层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你二叉树的根节点 root ，返回其节点值的层序遍历 。 （即逐层地，从左到右访问所有节点）。
        // 输入：root = [3,9,20,null,null,15,7]
        // 输出：[[3],[9,20],[15,7]]
        // 示例 2：
        // 输入：root = [1]
        // 输出：[[1]]
        // 广度优先遍历

        // let root = arrayToTree([3, 9, 20, null, null, 15, 7])

        // // console.log('root', root)

        // var levelOrder = function (root) {
        //     //二叉树的层序遍历
        //     let res = [], queue = [];
        //     queue.push(root);
        //     if (root === null) {
        //         return res;
        //     }
        //     while (queue.length !== 0) {
        //         // 记录当前层级节点数
        //         let length = queue.length;
        //         //存放每一层的节点 
        //         let curLevel = [];
        //         for (let i = 0; i < length; i++) {
        //             let node = queue.shift(); // 取节点，存值，
        //             curLevel.push(node.val);
        //             // 存放当前层下一层的节点
        //             node.left && queue.push(node.left);
        //             node.right && queue.push(node.right);
        //         }
        //         //把每一层的结果放到结果数组
        //         res.push(curLevel);
        //     }
        //     return res;
        // };

        // console.log(levelOrder(root))

        // // Todo: 输出二叉树的非子叶节点
        // // 深度优先搜索（DFS）递归
        // function getNonLeafNodesDFS(root) {
        //     let nonLeafNodes = []
        //     function dfs(rootNode) {
        //         if (rootNode == null) return
        //         if (rootNode.left || rootNode.right) {
        //             res.push(rootNode.val)
        //         }
        //         dfs(rootNode.left)
        //         dfs(rootNode.right)
        //     }
        //     dfs(root)
        //     return nonLeafNodes
        // }

        // function getNonLeafNodesBFS(root) {
        //     if (!root) return [];
        //     const nonLeafNodes = [];
        //     const queue = [root];
        //     while (queue.length) {
        //         const node = queue.shift();
        //         if (node.left || node.right) {
        //             nonLeafNodes.push(node.val);
        //         }
        //         if (node.left) queue.push(node.left);
        //         if (node.right) queue.push(node.right);
        //     }
        //     return nonLeafNodes;
        // }


        // Todo: 接雨水问题
        // https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked
        // 双指针索引法
        // 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
        // 示例 1：
        // 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
        // 输出：6
        // 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

        // function solution(list) {
        //     let res = 0, left = 0, right = list.length - 1, leftMax = 0, rightMax = 0;
        //     while (left < right) {
        //         if (list[left] < list[right]) {
        //             if (list[left] > leftMax) {
        //                 leftMax = list[left]
        //             } else {
        //                 let currGap = leftMax - list[left]
        //                 res += currGap
        //             }
        //             left++
        //         } else {
        //             if (list[right] > rightMax) {
        //                 rightMax = list[right]
        //             } else {
        //                 let currGap = rightMax - list[right]
        //                 res += currGap
        //             }
        //             right--
        //         }
        //     }
        //     return res
        // }

        // console.log(solution([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))


        // Todo: 136. 只出现一次的数字
        // 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
        // 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
        // https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked
        /**
         * @param {number[]} nums
         * @return {number}
         */

        // var singleNumber = function (nums) {
        //     let res = null
        //     let map = Object.create(null)
        //     nums.forEach(num => {
        //         if (map[num]) {
        //             item = map[num]
        //             item.count = item.count + 1
        //         } else {
        //             map[num] = {
        //                 count: 1,
        //                 val: num
        //             }
        //         }
        //     })
        //     console.log('map', map)
        //     Object.values(map).forEach(obj => {
        //         if (obj.count == 1) {
        //             res = obj.val
        //         }
        //     })
        //     return res

        // };

        // // Todo: 解题核心其余每一个元素都出现 2 次，多了也不行
        // var singleNumber = function (nums) {
        //     let ans = 0;
        //     for (const num of nums) {
        //         ans ^= num;
        //     }
        //     return ans;
        // };
        // console.log(singleNumber([4, 1, 2, 1, 2]))

        // // Todo: 二叉树中序续遍历 左 -> 根 -> 右
        // var inorderTraversal = function (root) {
        //     const res = [];
        //     const inorder = (root) => {
        //         if (!root) {
        //             return;
        //         }
        //         inorder(root.left);
        //         res.push(root.val);
        //         inorder(root.right);
        //     }
        //     inorder(root);
        //     return res;
        // };


        // Todo: 杨辉三角问题 - 字节面试题
        // https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked
        // 方法一：
        // function solution(numRows) {
        //     let res = []
        //     for (let i = 0; i < numRows; i++) {
        //         let currentArr = new Array(i + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[i - 1][j - 1] + res[i - 1][j];
        //         }
        //         res.push(currentArr)
        //     }
        //     return res;
        // }

        // 方法二：
        // function solution(numRows) {
        //     let res = [], initRow = 0;
        //     function inner(currentRow) {
        //         if (currentRow == numRows) {
        //             return
        //         }
        //         let currentArr = new Array(currentRow + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[currentRow - 1][j - 1] + res[currentRow - 1][j]
        //         }
        //         res.push(currentArr)
        //         currentRow += 1
        //         inner(currentRow)
        //     }
        //     inner(initRow)
        //     return res
        // }
        // console.log(solution(5))


        // Todo: - 字节面试题
        // * 已知有一
        // *@param a
        // * @param b
        // * @returns
        // async function addRemote(a: number, b: number) {await new Promise((resolve)=>setTimeout(resolveMath.random()* 100));
        // return a + b;
        // 米米
        // *请实现本地的 add 方法，调用 addRemote，能最优的实现输入数字的加法。
        // *@example
        // * add(5,6).then(result =>{
        // console.log(result); // 11
        // *});
        // * add(1, 4,3, 3, 5).then(result =>{
        // *console.log(result); // 16
        // *})
        // *add(2,3,3,3,4,1, 3, 3, 5).then(result =>{
        // console.log(result); // 27
        // *})
        // Promise<number> 
        // async function add(...inputs) {// 你的实现
        // }

        // Todo: 最长连续序列
        // https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
        // 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 示例 1：
        // 输入：nums = [100,4,200,1,3,2]
        // 输出：4
        // 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

        // 示例 2：
        // 输入：nums = [0,3,7,2,5,8,4,6,0,1]
        // 输出：9

        // 示例 3：
        // 输入：nums = [1,0,1,2]
        // 输出：3

        // 不行
        // function solution(nums) {
        //     let res = [], start = 0, max = 0
        //     nums.sort((a, b) => a - b)
        //     for (let i = 0; i < nums.length; i++) {
        //         const element = nums[i]
        //         if (element + 1 == nums[i + 1]) {
        //             // 连续
        //         } else if (element == nums[i + 1]) {
        //             // 相同
        //             start = i + 1
        //         } else {
        //             // 不连续
        //             let arr = [...nums].slice(start, i + 1)
        //             max = Math.max(max, arr.length)
        //             start = i + 1
        //         }
        //     }
        //     return max
        // }

        // var longestConsecutive = function (nums) {
        //     let ans = 0;
        //     const st = new Set(nums); // 把 nums 转成哈希集合
        //     for (const x of st) { // 遍历哈希集合
        //         if (st.has(x - 1)) {
        //             continue;
        //         }
        //         // x 是序列的起点
        //         let y = x + 1;
        //         while (st.has(y)) { // 不断查找下一个数是否在哈希集合中
        //             y++;
        //         }
        //         // 循环结束后，y-1 是最后一个在哈希集合中的数
        //         ans = Math.max(ans, y - x); // 从 x 到 y-1 一共 y-x 个数
        //     }
        //     return ans;
        // };

        // console.log(solution([100, 4, 200, 1, 3, 2]))


        // Todo: 移动零
        // https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
        // 请注意 ，必须在不复制数组的情况下原地对数组进行操作。
        // 示例 1:
        // 输入: nums = [0,1,0,3,12]
        // 输出: [1,3,12,0,0]

        // 示例 2:
        // 输入: nums = [0]
        // 输出: [0]

        // function solution(nums) {
        //     let res = [], zoreList = []
        //     nums.forEach((item) => {
        //         if (item == 0) {
        //             zoreList.push(item)
        //         } else {
        //             res.push(item)
        //         }
        //     })
        //     return res.sort((a, b) => a - b).concat(zoreList)
        // }

        // var moveZeroes = function (nums) {
        //     let slow = 0
        //     for (let fast = 0; fast < nums.length; fast++) {
        //         if (nums[fast] !== 0) {
        //             nums[slow] = nums[fast]
        //             slow++
        //         }
        //     }
        //     nums.fill(0, slow)
        //     return nums
        // };

        // console.log(moveZeroes([0, 1, 0, 3, 12]))

        // function solution(nums) {
        //     let slow = 0
        //     for (let right = 0; right < nums.length; right++) {
        //         if (nums[right] != 0) {
        //             nums[slow] = nums[right]
        //             slow++
        //         }
        //     }
        //     nums.fill(0, slow)
        //     return nums
        // }

        // Todo: 矩阵置零
        // https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        /**
         * @param {number[][]} matrix
         * @return {void} Do not return anything, modify matrix in-place instead.
         */
        // 解题思路，先标记 0 的下标，然后转化问题，在 matrix 里面只要有一个下标符合，就置为 0 
        // var setZeroes = function (matrix) {
        //     // 记录 m 和 n
        //     const m = matrix.length, n = matrix[0].length
        //     const row = new Array(m).fill(false)
        //     const col = new Array(n).fill(false)
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }
        //     return matrix
        // };

        // Todo: 合并区间
        // https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
        // 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。
        // 请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
        // 示例 1：
        // 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
        // 输出：[[1,6],[8,10],[15,18]]
        // 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

        // 示例 2：
        // 输入：intervals = [[1,4],[4,5]]
        // 输出：[[1,5]]
        // 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
        // 解析思路是啥：
        // Tip: 注意点在于：每一个区间只有两个元素，不会存在多个元素的情况。

        // var merge = function (intervals) {
        //     intervals.sort((a, b) => a[0] - b[0]); // 区间左端点排序，从小到大
        //     // console.log('sort intervals', intervals.slice())
        //     const merged = [];
        //     let i = -1;
        //     intervals.forEach((range) => {
        //         const [start, end] = range;
        //         const [preStart, preEnd] = merged[i] ?? [];
        //         if (merged.length === 0 || (start > preEnd)) {
        //             merged.push(range);
        //             i += 1;
        //         } else if (end > preEnd) {
        //             merged[i][1] = end;
        //         }
        //     });
        //     return merged;
        // }
        // // console.log(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))
        // console.log(merge([[4, 5], [1, 4]]))


        // Todo: 矩阵置零
        // 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        // 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
        // 输出：[[1,0,1],[0,0,0],[1,0,1]]
        // 解题思路：
        // 1. 使用 m, n 长度的数组，标记元素 0 的，假如 matrix[1][1] = 0, 则 m[1] = n[1] = true
        // 2. 遍历嵌套遍历，m，n，m[1]，n[1]

        // function solution(matrix) {
        //     let m = matrix.length
        //     let n = matrix[0].length

        //     let row = new Array(m).fill(false)
        //     let col = new Array(n).fill(false)

        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //                 // 标记位置
        //             }
        //         }
        //     }

        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }

        //     return matrix
        // }

        // var setZeroes = function (matrix) {
        //     // 记录 m 和 n
        //     const m = matrix.length, n = matrix[0].length
        //     const row = new Array(m).fill(false)
        //     const col = new Array(n).fill(false)
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] == 0) {
        //                 row[i] = col[j] = true
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0
        //             }
        //         }
        //     }
        //     return matrix
        // };

        // console.log(solution([[1,1,1],[1,0,1],[1,1,1]]))
        // console.log(setZeroes([[1,1,1],[1,0,1],[1,1,1]]))

        // Todo: 对象扁平化 flatten
        // 解题思路：递归判断 val 的类型，如果是对象或者数组，则继续遍历，将keyPath链接，否则
        // output[keyPath] = val, 挂在输出对象返回。
        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }
        // flatten(obj) 结果返回如下
        // {
        //  'a.b': 1,
        //  'a.c': 2,
        //  'a.d.e': 5,
        //  'b[0]': 1,
        //  'b[1]': 3,
        //  'b[2].a': 2,
        //  'b[2].b': 3
        //   c: 3
        // }

        // 类型判断
        // function getTepy(obj) {
        //     return Object.prototype.toString.call(obj).slice(8, -1)
        // }
        // function objectFlatten(Obj) {
        //     if (getTepy(Obj) != 'Object') {
        //         return
        //     }
        //     let output = {}
        //     function inner(source, keyPath) {
        //         if (getTepy(source) == 'Object') {
        //             for (const key in source) {
        //                 if (Object.prototype.hasOwnProperty.call(source, key)) {
        //                     let nextKeyPath = keyPath ? `${keyPath}.${key}` : `${key}`
        //                     inner(source[key], nextKeyPath)
        //                 }
        //             }
        //         } else if (getTepy(source) == 'Array') {
        //             source.forEach((item, index) => {
        //                 let nextKeyPath = `${keyPath}[${index}]`
        //                 inner(item, nextKeyPath)
        //             });
        //         } else {
        //             output[keyPath] = source
        //         }
        //     }
        //     inner(Obj, '')
        //     return output
        // }
        // console.log(objectFlatten(obj))

        // Todo: 对象扁平化 flattenRecovery()
        // const source = {
        //     'a.b': 1,
        //     'a.c': 2,
        //     'a.d.e': 5,
        //     'b[0]': 1,
        //     'b[1]': 3,
        //     'b[2].a': 2,
        //     'b[2].b': 3,
        //     'c': 3
        // }

        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }

        // function transformObject(sourceObj) {
        //     let result = {}
        //     Object.keys(sourceObj).forEach((key) => {
        //         const reg = /[\.\[\]]+/
        //         const keyList = key.split(reg).filter(Boolean)
        //         // console.log('keyList', keyList)
        //         let currentLevel = result
        //         for (let i = 0; i < keyList.length; i++) {
        //             const value = sourceObj[key]
        //             const currentPath = keyList[i]
        //             // 判断 i 索引的位置
        //             if (i < keyList.length - 1) {
        //                 if (currentLevel[currentPath] == undefined) {
        //                     currentLevel[currentPath] = isNaN(Number(keyList[i + 1])) ? {} : []
        //                 }
        //             } else if (i = keyList.length - 1) {
        //                 currentLevel[currentPath] = value
        //             }
        //             currentLevel = currentLevel[currentPath]
        //         }
        //     })
        //     return result
        // }
        // console.log(transformObject(source))

        // function getValueByPath(sourceObj, pathStr, defaultValue) {
        //     const reg = /[\.\[\]]+/
        //     const paths = pathStr.split(reg).filter(Boolean)
        //     for (let i = 0; i < paths.length; i++) {
        //         // 判断 path 是字符串还是数字
        //         const currentPath = isNaN(Number(paths[i])) ? paths[i] : Number(paths[i])
        //         if (Object.prototype.hasOwnProperty.call(sourceObj, currentPath)) {
        //             let currentValue = sourceObj[currentPath]
        //             if (currentValue === undefined) {
        //                 return defaultValue
        //             } else {
        //                 if (i < paths.length - 1) {
        //                     sourceObj = currentValue
        //                 } else if (i == paths.length - 1) {
        //                     return currentValue
        //                 }
        //             }
        //         }
        //     }
        // }

        // const obj = {
        //   a: {
        //     b: 1,
        //     c: 2,
        //     d: {e: 5}
        //   },
        //   b: [1, 3, {a: 2, b: 3}],
        //   c: 3
        // }
        // // b[2].a
        // console.log(getValueByPath(obj, 'b[2].a'))

        // Todo: 实现一个字符串风格转换函数 camelCase
        // 提示: 使用正则表达式解析文本
        // function camelCase(str) {
        // // return xxx
        // }

        // // 用例如下：
        // // 注：字符串中仅出现 英文字母、短横线 和 下划线
        // const pascal = 'ThisIsASentence'
        // const snake = 'this_is_a_sentence'
        // const hyphen = 'this-is-a-sentence'
        // const constant = 'THIS_IS_A_SENTENCE'

        // camelCase(pascal) // -> thisIsASentence
        // camelCase(snake) // -> thisIsASentence
        // camelCase(hyphen) // -> thisIsASentence
        // camelCase(constant) // -> thisIsASentence

        // function camelCase(str) {
        //     const strList = str.split(/[_-]+/).filter(Boolean);
        //     if (strList.length === 1) {
        //         let currentWord = strList[0]
        //         return currentWord[0].toLowerCase() + currentWord.slice(1);
        //     }
        //     return generateCamelCase(strList);
        // }

        // function generateCamelCase(strList) {
        //     return strList
        //         .map((word, index) => {
        //             if (index === 0) {
        //                 return word.toLowerCase();
        //             }
        //             return word[0].toUpperCase() + word.slice(1).toLowerCase();
        //         })
        //         .join('');
        // }
        // // 测试用例
        // const pascal = 'ThisIsASentence';
        // const snake = 'this_is_a_sentence';
        // const hyphen = 'this-is-a-sentence';
        // const constant = 'THIS_IS_A_SENTENCE';
        // console.log(camelCase(pascal));    // -> "thisIsASentence"
        // console.log(camelCase(snake));     // -> "thisIsASentence"
        // console.log(camelCase(hyphen));    // -> "thisIsASentence"
        // console.log(camelCase(constant));  // -> "thisIsASentence"

        // console.log(camelCase(pascal))
        // console.log(camelCase(snake))
        // console.log(camelCase(hyphen))
        // console.log(camelCase(constant))
        // -> thisIsASentence
        // -> thisIsASentence
        // -> thisIsASentence
        // -> thisIsASentence

        // var length = 10; function fn() { return this.length + 1; }
        // var obj = { length: 5, test1: function () { return fn(); } }
        // obj.test2 = fn;
        // //下面代码输出是什么
        // console.log(obj.test1()) // 11
        // // console.log(fn() === obj.test2()) // 11 6
        // console.log(obj.test2())

        // function camelCase(str) {
        // return str
        //     // 处理下划线和短横线：将 _ 或 - 后的字母转为大写
        //     .replace(/[-_]([a-z])/g, (_, char) => char.toUpperCase())
        //     // 处理 CONSTANT_CASE（全大写）：将所有 _ 后的字母转为大写，并首字母小写
        //     .replace(/_([A-Z])/g, (_, char) => char)
        //     // 确保首字母是小写（处理 PascalCase）
        //     .replace(/^[A-Z]/, (firstChar) => firstChar.toLowerCase());
        // }

        // // 测试用例
        // const pascal = 'ThisIsASentence';
        // const snake = 'this_is_a_sentence';
        // const hyphen = 'this-is-a-sentence';
        // const constant = 'THIS_IS_A_SENTENCE';

        // console.log(camelCase(pascal));    // -> "thisIsASentence"
        // console.log(camelCase(snake));     // -> "thisIsASentence"
        // console.log(camelCase(hyphen));    // -> "thisIsASentence"
        // console.log(camelCase(constant));  // -> "thisIsASentence"



        // 来未来笔试题
        // Todo: 
        // 实现一个 submit 函数，控制函数，0.5s内重复点击不触发，1.5s后触发一次，而且首次一次执行
        // 
        // const submitForm = function (res) {
        //     console.log('submit' + res)
        // }
        // const submit = handleSubmit(submitForm, 1000)

        // function handleSubmit(fn, delay) {
        //     let lastExecTime = 0;  // 上次执行时间
        //     let timer = null;      // 定时器
        //     let isFirstCall = true; // 是否是第一次调用

        //     return function (...args) {
        //         const now = Date.now();
        //         // 清除之前的定时器
        //         if (timer) {
        //             clearTimeout(timer);
        //             timer = null;
        //         }
        //         // 第一次调用立即执行
        //         if (isFirstCall) {
        //             fn.apply(this, args);
        //             lastExecTime = now;
        //             isFirstCall = false;
        //             return;
        //         }

        //         // 计算距离上次执行的时间
        //         const timeSinceLastExec = now - lastExecTime;
        //         // 如果距离上次执行不足500ms，则忽略
        //         if (timeSinceLastExec < 500) {
        //             return;
        //         }
        //         // 如果距离上次执行在500ms-1500ms之间，则设置定时器
        //         // Todo: 待思考？
        //         if (timeSinceLastExec < 1500) {
        //             timer = setTimeout(() => {
        //                 fn.apply(this, args);
        //                 lastExecTime = Date.now();
        //             }, 1500 - timeSinceLastExec);
        //             return;
        //         }
        //         // 如果距离上次执行超过1500ms，则立即执行
        //         fn.apply(this, args);
        //         lastExecTime = now;
        //     };
        // }

        // submit(1)
        // submit(2)
        // setTimeout(() => {
        //     submit(3)
        //     setTimeout(() => {
        //         submit(4)
        //         setTimeout(() => {
        //             submit(5)
        //             setTimeout(() => {
        //                 submit(6)
        //                 setTimeout(() => {
        //                     submit(7)
        //                     setTimeout(() => {
        //                         submit(8)
        //                     }, 800);
        //                 }, 200);
        //             }, 1000);
        //         }, 500);
        //     }, 200);
        // }, 100);

        // 输出
        // submit1
        // submit6


        // 第二题：
        // 文件路径转树形结构解决方案
        // 根据你的需求，我们需要将文件路径字符串数组转换为树形结构，用于Tree组件展示。
        // 我将实现三个函数来完成这个转换过程。
        // 对于输入 ['aa.bb', 'aa.cc.bb', 'cc.aa.bb.bb', 'bb.cc.bb.dd.aa.cc']，输出结构如下：


        // 将路径数组转换为带有id和parentId的扁平列表
        // const toList = (arr) => {
        //     const list = [];
        //     const seen = new Set(); // 用于去重

        //     arr.forEach(path => {
        //         const segments = path.split('.');
        //         let parentId = null;

        //         segments.forEach((segment, index) => {
        //             const id = parentId ? `${parentId}.${segment}` : segment;
        //             // 如果这个节点已经处理过则跳过
        //             if (!seen.has(id)) {
        //                 seen.add(id);
        //                 list.push({
        //                     title: segment,
        //                     parentId: parentId,
        //                     id: id,
        //                     key: id,
        //                     children: null
        //                 });
        //             }

        //             parentId = id;
        //         });
        //     });

        //     return list;
        // };

        // // 将扁平列表转换为树形结构
        // // 这个递归的逻辑是什么？
        // const toTree = (list, parentId = null) => {
        //     const tree = [];

        //     list.forEach(item => {
        //         if (item.parentId === parentId) {
        //             const children = toTree(list, item.id);
        //             if (children.length > 0) {
        //                 item.children = children;
        //             }
        //             tree.push(item);
        //         }
        //     });

        //     return tree;
        // };

        // // 整合函数，直接生成Tree组件需要的数据
        // const toTreeData = (arr) => {
        //     const list = toList(arr);
        //     console.log('list', list)
        //     return toTree(list);
        // };

        // // 测试数据
        // const arr = ['aa.dd', 'bb.cc.ff', 'cc.aa.bb.bb', 'bb.cc.bb.dd.aa.cc'];
        // const treeData = toTreeData(arr);
        // console.log(JSON.stringify(treeData, null, 2));


        // Todo: 第三题
        // 设计一个英文单词字典，请实现字典检索方法wordFilter.findWord，
        // 通过单词的前后缀来检索单词位置。当符合条件的单词不止一个时，返回最大下标。
        // 实际使用场景中需要考虑字典多次检索效率(时间复杂度与空间复杂度)，
        // 保证单次检索wordFilter.findWord 的效率最高。

        // class WordFilter {
        //     constructor(words) {
        //         this.prefixMap = new Map();
        //         this.suffixMap = new Map();
        //         this.wordIndices = new Map();

        //         // 构建索引 
        //         for (let i = 0; i < words.length; i++) {
        //             const word = words[i];
        //             this.wordIndices.set(word, i);

        //             // 构建前缀索引
        //             for (let j = 0; j <= word.length; j++) {
        //                 const prefix = word.substring(0, j);
        //                 if (!this.prefixMap.has(prefix)) {
        //                     this.prefixMap.set(prefix, new Set());
        //                 }
        //                 this.prefixMap.get(prefix).add(word);
        //             }

        //             // 构建后缀索引
        //             for (let j = 0; j <= word.length; j++) {
        //                 const suffix = word.substring(word.length - j);
        //                 if (!this.suffixMap.has(suffix)) {
        //                     this.suffixMap.set(suffix, new Set());
        //                 }
        //                 this.suffixMap.get(suffix).add(word);
        //             }
        //         }
        //     }

        //     findWord(prefix, suffix = '') {
        //         let prefixWords = this.prefixMap.get(prefix) || new Set();
        //         let suffixWords = this.suffixMap.get(suffix) || new Set();

        //         // 找到同时满足前缀和后缀的单词
        //         const intersection = new Set(
        //             [...prefixWords].filter(word => suffixWords.has(word))
        //         );

        //         if (intersection.size === 0) return null;

        //         // 返回最大索引的单词
        //         let maxIndex = -1;
        //         let result = null;
        //         intersection.forEach(word => {
        //             const index = this.wordIndices.get(word);
        //             if (index > maxIndex) {
        //                 maxIndex = index;
        //                 result = word;
        //             }
        //         });

        //         return result;
        //     }
        // }
        // // 测试用例
        // const wordFilter = new WordFilter(['apple', 'banana', 'orange', 'bana']);

        // console.log(wordFilter.findWord('a', 'e')); // 'apple'
        // console.log(wordFilter.findWord('b', 'a')); // 'banana'
        // console.log(wordFilter.findWord('c', 'c')); // null
        // console.log(wordFilter.findWord('d', 'd')); // null
        // console.log(wordFilter.findWord('e', 'f')); // null
        // console.log(wordFilter.findWord('g')); // null

        // deepClone 强化版本
        function deepClone(obj, hash = new WeakMap()) {
            // 处理基本类型和null
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            // 处理循环引用
            if (hash.has(obj)) {
                return hash.get(obj);
            }
            // 处理Date
            if (obj instanceof Date) {
                const copy = new Date(obj);
                hash.set(obj, copy);
                return copy;
            }
            // 处理RegExp
            if (obj instanceof RegExp) {
                const copy = new RegExp(obj);
                hash.set(obj, copy);
                return copy;
            }
            // 处理Map
            if (obj instanceof Map) {
                const copy = new Map();
                hash.set(obj, copy);
                obj.forEach((value, key) => {
                    copy.set(deepClone(key, hash), deepClone(value, hash));
                });
                return copy;
            }
            // 处理Set
            if (obj instanceof Set) {
                const copy = new Set();
                hash.set(obj, copy);
                obj.forEach(value => {
                    copy.add(deepClone(value, hash));
                });
                return copy;
            }
            // 处理数组和普通对象
            const clone = Array.isArray(obj) ? [] : {};
            hash.set(obj, clone);
            // 处理Symbol属性
            const symKeys = Object.getOwnPropertySymbols(obj);
            for (const symKey of symKeys) {
                clone[symKey] = deepClone(obj[symKey], hash);
            }
            // 处理普通属性
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    clone[key] = deepClone(obj[key], hash);
                }
            }
            return clone;
        }

        function deepClone(obj) {
            return structuredClone(obj);
        }


        










































































    </script>

</body>

</html>