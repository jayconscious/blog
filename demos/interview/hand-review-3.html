<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Todo: 最长回文串
        // 方法三：中心扩展法（最优解）
        // 思路：以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。
        // 时间复杂度：O(n²)。
        // 空间复杂度：O(1)。
        // function longestPalindrome(s) {
        //     let max = '';
        //     for (let i = 0; i < s.length; i++) {
        //         // 奇数长度回文（以s[i]为中心）
        //         const odd = expandAroundCenter(s, i, i);
        //         // 偶数长度回文（以s[i]和s[i+1]为中心）
        //         const even = expandAroundCenter(s, i, i + 1);
        //         // 更新最大值
        //         if (odd.length > max.length) max = odd;
        //         if (even.length > max.length) max = even;
        //     }
        //     return max;
        // }
        // function expandAroundCenter(s, left, right) {
        //     while (left >= 0 && right < s.length && s[left] === s[right]) {
        //         left--;
        //         right++;
        //     }
        //     return s.slice(left + 1, right); // 注意边界
        // }
        // console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"


        // Todo: 质数因子
        // 180
        // function solution(num) {
        //     let res = [];
        //     let i = 2;
        //     while (i <= num && i * i <= num) {
        //         if (num % i === 0) {
        //             res.push(i);
        //             num = num / i;
        //             i = 2;
        //         } else {
        //             i++
        //         }
        //     }
        //     if (num !== 1) {
        //         res.push(i)
        //     }
        //     return res.join(' ');
        // }
        // console.log(solution(180))

        // let floatNum = readline();
        // let res = parseFloat(floatNum).toFixed(0)
        // console.log(res)


        // Todo: b是否是a的子集
        // a和b有重复元素，要求b的同个元素出现次数<=a的同个元素出现次数

        // function isSubset(a, b) {
        //     // 统计a中每个元素的出现次数
        //     const frequencyMap = {};
        //     for (const elem of a) {
        //         frequencyMap[elem] = frequencyMap[elem] ? frequencyMap[elem] + 1 : 1;
        //     }

        //     // 检查b中的每个元素是否都在a中且出现次数不超过
        //     for (const elem of b) {
        //         if (!frequencyMap[elem]) {
        //             return false;  // 元素不存在于a中
        //         }
        //         frequencyMap[elem]--;
        //         if (frequencyMap[elem] < 0) {
        //             return false;  // 元素出现次数超过a中的次数
        //         }
        //     }

        //     return true;
        // }

        // // 示例
        // const a = [1, 2, 2, 3, 4];
        // const b1 = [2, 2];  // 是子集
        // const b2 = [2, 2, 2];  // 不是子集（2出现3次 > a中的2次）

        // console.log(isSubset(a, b1)); // true
        // console.log(isSubset(a, b2)); // false

        // Todo: 将一串数组节点转化为二叉树

        // function TreeNode(val, left, right) {
        //     this.val = (val === undefined ? 0 : val);
        //     this.left = (left === undefined ? null : left);
        //     this.right = (right === undefined ? null : right);
        // }
        // function arrayToTree(arr, index = 0) {
        //     if (index >= arr.length || arr[index] === null) {
        //         return null;
        //     }
        //     const node = new TreeNode(arr[index]);
        //     node.left = arrayToTree(arr, 2 * index + 1);  // 左子节点索引
        //     node.right = arrayToTree(arr, 2 * index + 2); // 右子节点索引
        //     return node;
        // }

        // const arr = [1, 2, 3, 4, 5, 6, 7];
        // const root = arrayToTree(arr);
        // console.log(root);

        // Todo: 二叉树层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你二叉树的根节点 root ，返回其节点值的层序遍历 。 （即逐层地，从左到右访问所有节点）。
        // 输入：root = [3,9,20,null,null,15,7]
        // 输出：[[3],[9,20],[15,7]]
        // 示例 2：
        // 输入：root = [1]
        // 输出：[[1]]
        // 广度优先遍历

        // let root = arrayToTree([3, 9, 20, null, null, 15, 7])

        // // console.log('root', root)

        // var levelOrder = function (root) {
        //     //二叉树的层序遍历
        //     let res = [], queue = [];
        //     queue.push(root);
        //     if (root === null) {
        //         return res;
        //     }
        //     while (queue.length !== 0) {
        //         // 记录当前层级节点数
        //         let length = queue.length;
        //         //存放每一层的节点 
        //         let curLevel = [];
        //         for (let i = 0; i < length; i++) {
        //             let node = queue.shift(); // 取节点，存值，
        //             curLevel.push(node.val);
        //             // 存放当前层下一层的节点
        //             node.left && queue.push(node.left);
        //             node.right && queue.push(node.right);
        //         }
        //         //把每一层的结果放到结果数组
        //         res.push(curLevel);
        //     }
        //     return res;
        // };

        // console.log(levelOrder(root))

        // // Todo: 输出二叉树的非子叶节点
        // // 深度优先搜索（DFS）递归
        // function getNonLeafNodesDFS(root) {
        //     let nonLeafNodes = []
        //     function dfs(rootNode) {
        //         if (rootNode == null) return
        //         if (rootNode.left || rootNode.right) {
        //             res.push(rootNode.val)
        //         }
        //         dfs(rootNode.left)
        //         dfs(rootNode.right)
        //     }
        //     dfs(root)
        //     return nonLeafNodes
        // }

        // function getNonLeafNodesBFS(root) {
        //     if (!root) return [];
        //     const nonLeafNodes = [];
        //     const queue = [root];
        //     while (queue.length) {
        //         const node = queue.shift();
        //         if (node.left || node.right) {
        //             nonLeafNodes.push(node.val);
        //         }
        //         if (node.left) queue.push(node.left);
        //         if (node.right) queue.push(node.right);
        //     }
        //     return nonLeafNodes;
        // }


        // Todo: 接雨水问题
        // https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked
        // 双指针索引法
        // 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
        // 示例 1：
        // 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
        // 输出：6
        // 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

        // function solution(list) {
        //     let res = 0, left = 0, right = list.length - 1, leftMax = 0, rightMax = 0;
        //     while (left < right) {
        //         if (list[left] < list[right]) {
        //             if (list[left] > leftMax) {
        //                 leftMax = list[left]
        //             } else {
        //                 let currGap = leftMax - list[left]
        //                 res += currGap
        //             }
        //             left++
        //         } else {
        //             if (list[right] > rightMax) {
        //                 rightMax = list[right]
        //             } else {
        //                 let currGap = rightMax - list[right]
        //                 res += currGap
        //             }
        //             right--
        //         }
        //     }
        //     return res
        // }

        // console.log(solution([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))


        // Todo: 136. 只出现一次的数字
        // 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
        // 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
        // https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked
        /**
         * @param {number[]} nums
         * @return {number}
         */

        // var singleNumber = function (nums) {
        //     let res = null
        //     let map = Object.create(null)
        //     nums.forEach(num => {
        //         if (map[num]) {
        //             item = map[num]
        //             item.count = item.count + 1
        //         } else {
        //             map[num] = {
        //                 count: 1,
        //                 val: num
        //             }
        //         }
        //     })
        //     console.log('map', map)
        //     Object.values(map).forEach(obj => {
        //         if (obj.count == 1) {
        //             res = obj.val
        //         }
        //     })
        //     return res

        // };

        // // Todo: 解题核心其余每一个元素都出现 2 次，多了也不行
        // var singleNumber = function (nums) {
        //     let ans = 0;
        //     for (const num of nums) {
        //         ans ^= num;
        //     }
        //     return ans;
        // };
        // console.log(singleNumber([4, 1, 2, 1, 2]))

        // // Todo: 二叉树中序续遍历 左 -> 根 -> 右
        // var inorderTraversal = function (root) {
        //     const res = [];
        //     const inorder = (root) => {
        //         if (!root) {
        //             return;
        //         }
        //         inorder(root.left);
        //         res.push(root.val);
        //         inorder(root.right);
        //     }
        //     inorder(root);
        //     return res;
        // };


        // Todo: 杨辉三角问题 - 字节面试题
        // https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked
        // 方法一：
        // function solution(numRows) {
        //     let res = []
        //     for (let i = 0; i < numRows; i++) {
        //         let currentArr = new Array(i + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[i - 1][j - 1] + res[i - 1][j];
        //         }
        //         res.push(currentArr)
        //     }
        //     return res;
        // }

        // 方法二：
        // function solution(numRows) {
        //     let res = [], initRow = 0;
        //     function inner(currentRow) {
        //         if (currentRow == numRows) {
        //             return
        //         }
        //         let currentArr = new Array(currentRow + 1).fill(1)
        //         for (let j = 1; j < currentArr.length - 1; j++) {
        //             currentArr[j] = res[currentRow - 1][j - 1] + res[currentRow - 1][j]
        //         }
        //         res.push(currentArr)
        //         currentRow += 1
        //         inner(currentRow)
        //     }
        //     inner(initRow)
        //     return res
        // }
        // console.log(solution(5))


        // Todo: - 字节面试题
        // * 已知有一
        // *@param a
        // * @param b
        // * @returns
        // async function addRemote(a: number, b: number) {await new Promise((resolve)=>setTimeout(resolveMath.random()* 100));
        // return a + b;
        // 米米
        // *请实现本地的 add 方法，调用 addRemote，能最优的实现输入数字的加法。
        // *@example
        // * add(5,6).then(result =>{
        // console.log(result); // 11
        // *});
        // * add(1, 4,3, 3, 5).then(result =>{
        // *console.log(result); // 16
        // *})
        // *add(2,3,3,3,4,1, 3, 3, 5).then(result =>{
        // console.log(result); // 27
        // *})
        // Promise<number> 
        // async function add(...inputs) {// 你的实现
        // }

        // Todo: 最长连续序列
        // https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
        // 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
        // 示例 1：
        // 输入：nums = [100,4,200,1,3,2]
        // 输出：4
        // 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

        // 示例 2：
        // 输入：nums = [0,3,7,2,5,8,4,6,0,1]
        // 输出：9

        // 示例 3：
        // 输入：nums = [1,0,1,2]
        // 输出：3

        // 不行
        // function solution(nums) {
        //     let res = [], start = 0, max = 0
        //     nums.sort((a, b) => a - b)
        //     for (let i = 0; i < nums.length; i++) {
        //         const element = nums[i]
        //         if (element + 1 == nums[i + 1]) {
        //             // 连续
        //         } else if (element == nums[i + 1]) {
        //             // 相同
        //             start = i + 1
        //         } else {
        //             // 不连续
        //             let arr = [...nums].slice(start, i + 1)
        //             max = Math.max(max, arr.length)
        //             start = i + 1
        //         }
        //     }
        //     return max
        // }

        // var longestConsecutive = function (nums) {
        //     let ans = 0;
        //     const st = new Set(nums); // 把 nums 转成哈希集合
        //     for (const x of st) { // 遍历哈希集合
        //         if (st.has(x - 1)) {
        //             continue;
        //         }
        //         // x 是序列的起点
        //         let y = x + 1;
        //         while (st.has(y)) { // 不断查找下一个数是否在哈希集合中
        //             y++;
        //         }
        //         // 循环结束后，y-1 是最后一个在哈希集合中的数
        //         ans = Math.max(ans, y - x); // 从 x 到 y-1 一共 y-x 个数
        //     }
        //     return ans;
        // };

        // console.log(solution([100, 4, 200, 1, 3, 2]))


        // Todo: 移动零
        // https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked
        // 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
        // 请注意 ，必须在不复制数组的情况下原地对数组进行操作。
        // 示例 1:
        // 输入: nums = [0,1,0,3,12]
        // 输出: [1,3,12,0,0]

        // 示例 2:
        // 输入: nums = [0]
        // 输出: [0]

        // function solution(nums) {
        //     let res = [], zoreList = []
        //     nums.forEach((item) => {
        //         if (item == 0) {
        //             zoreList.push(item)
        //         } else {
        //             res.push(item)
        //         }
        //     })
        //     return res.sort((a, b) => a - b).concat(zoreList)
        // }

        var moveZeroes = function (nums) {
            let slow = 0
            for (let fast = 0; fast < nums.length; fast++) {
                if (nums[fast] !== 0) {
                    nums[slow] = nums[fast]
                    slow++
                }
            }
            nums.fill(0, slow)
            return nums
        };

        console.log(moveZeroes([0, 1, 0, 3, 12]))












































    </script>

</body>

</html>