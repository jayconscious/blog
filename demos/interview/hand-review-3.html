<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Todo: 最长回文串
        // 方法三：中心扩展法（最优解）
        // 思路：以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。
        // 时间复杂度：O(n²)。
        // 空间复杂度：O(1)。
        // function longestPalindrome(s) {
        //     let max = '';
        //     for (let i = 0; i < s.length; i++) {
        //         // 奇数长度回文（以s[i]为中心）
        //         const odd = expandAroundCenter(s, i, i);
        //         // 偶数长度回文（以s[i]和s[i+1]为中心）
        //         const even = expandAroundCenter(s, i, i + 1);
        //         // 更新最大值
        //         if (odd.length > max.length) max = odd;
        //         if (even.length > max.length) max = even;
        //     }
        //     return max;
        // }
        // function expandAroundCenter(s, left, right) {
        //     while (left >= 0 && right < s.length && s[left] === s[right]) {
        //         left--;
        //         right++;
        //     }
        //     return s.slice(left + 1, right); // 注意边界
        // }
        // console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"


        // Todo: 质数因子
        // 180
        // function solution(num) {
        //     let res = [];
        //     let i = 2;
        //     while (i <= num && i * i <= num) {
        //         if (num % i === 0) {
        //             res.push(i);
        //             num = num / i;
        //             i = 2;
        //         } else {
        //             i++
        //         }
        //     }
        //     if (num !== 1) {
        //         res.push(i)
        //     }
        //     return res.join(' ');
        // }
        // console.log(solution(180))

        // let floatNum = readline();
        // let res = parseFloat(floatNum).toFixed(0)
        // console.log(res)


        // Todo: b是否是a的子集
        // a和b有重复元素，要求b的同个元素出现次数<=a的同个元素出现次数

        // function isSubset(a, b) {
        //     // 统计a中每个元素的出现次数
        //     const frequencyMap = {};
        //     for (const elem of a) {
        //         frequencyMap[elem] = frequencyMap[elem] ? frequencyMap[elem] + 1 : 1;
        //     }

        //     // 检查b中的每个元素是否都在a中且出现次数不超过
        //     for (const elem of b) {
        //         if (!frequencyMap[elem]) {
        //             return false;  // 元素不存在于a中
        //         }
        //         frequencyMap[elem]--;
        //         if (frequencyMap[elem] < 0) {
        //             return false;  // 元素出现次数超过a中的次数
        //         }
        //     }

        //     return true;
        // }

        // // 示例
        // const a = [1, 2, 2, 3, 4];
        // const b1 = [2, 2];  // 是子集
        // const b2 = [2, 2, 2];  // 不是子集（2出现3次 > a中的2次）

        // console.log(isSubset(a, b1)); // true
        // console.log(isSubset(a, b2)); // false

        // Todo: 将一串数组节点转化为二叉树

        // function TreeNode(val, left, right) {
        //     this.val = (val === undefined ? 0 : val);
        //     this.left = (left === undefined ? null : left);
        //     this.right = (right === undefined ? null : right);
        // }
        // function arrayToTree(arr, index = 0) {
        //     if (index >= arr.length || arr[index] === null) {
        //         return null;
        //     }
        //     const node = new TreeNode(arr[index]);
        //     node.left = arrayToTree(arr, 2 * index + 1);  // 左子节点索引
        //     node.right = arrayToTree(arr, 2 * index + 2); // 右子节点索引
        //     return node;
        // }

        // const arr = [1, 2, 3, 4, 5, 6, 7];
        // const root = arrayToTree(arr);
        // console.log(root);

        // Todo: 二叉树层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你二叉树的根节点 root ，返回其节点值的层序遍历 。 （即逐层地，从左到右访问所有节点）。
        // 输入：root = [3,9,20,null,null,15,7]
        // 输出：[[3],[9,20],[15,7]]
        // 示例 2：
        // 输入：root = [1]
        // 输出：[[1]]
        // 广度优先遍历

        // let root = arrayToTree([3, 9, 20, null, null, 15, 7])

        // // console.log('root', root)

        // var levelOrder = function (root) {
        //     //二叉树的层序遍历
        //     let res = [], queue = [];
        //     queue.push(root);
        //     if (root === null) {
        //         return res;
        //     }
        //     while (queue.length !== 0) {
        //         // 记录当前层级节点数
        //         let length = queue.length;
        //         //存放每一层的节点 
        //         let curLevel = [];
        //         for (let i = 0; i < length; i++) {
        //             let node = queue.shift(); // 取节点，存值，
        //             curLevel.push(node.val);
        //             // 存放当前层下一层的节点
        //             node.left && queue.push(node.left);
        //             node.right && queue.push(node.right);
        //         }
        //         //把每一层的结果放到结果数组
        //         res.push(curLevel);
        //     }
        //     return res;
        // };

        // console.log(levelOrder(root))

        // // Todo: 输出二叉树的非子叶节点
        // // 深度优先搜索（DFS）递归
        // function getNonLeafNodesDFS(root) {
        //     let nonLeafNodes = []
        //     function dfs(rootNode) {
        //         if (rootNode == null) return
        //         if (rootNode.left || rootNode.right) {
        //             res.push(rootNode.val)
        //         }
        //         dfs(rootNode.left)
        //         dfs(rootNode.right)
        //     }
        //     dfs(root)
        //     return nonLeafNodes
        // }

        // function getNonLeafNodesBFS(root) {
        //     if (!root) return [];
        //     const nonLeafNodes = [];
        //     const queue = [root];
        //     while (queue.length) {
        //         const node = queue.shift();
        //         if (node.left || node.right) {
        //             nonLeafNodes.push(node.val);
        //         }
        //         if (node.left) queue.push(node.left);
        //         if (node.right) queue.push(node.right);
        //     }
        //     return nonLeafNodes;
        // }


        // Todo: 接雨水问题
        // https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked
        // 双指针索引法
        // 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
        // 示例 1：
        // 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
        // 输出：6
        // 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

        // function solution(list) {
        //     let res = 0, left = 0, right = list.length - 1, leftMax = 0, rightMax = 0;
        //     while (left < right) {
        //         if (list[left] < list[right]) {
        //             if (list[left] > leftMax) {
        //                 leftMax = list[left]
        //             } else {
        //                 let currGap = leftMax - list[left]
        //                 res += currGap
        //             }
        //             left++
        //         } else {
        //             if (list[right] > rightMax) {
        //                 rightMax = list[right]
        //             } else {
        //                 let currGap = rightMax - list[right]
        //                 res += currGap
        //             }
        //             right--
        //         }
        //     }
        //     return res
        // }

        // console.log(solution([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]))


        // Todo: 136. 只出现一次的数字
        // 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
        // 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
        // https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked
        /**
         * @param {number[]} nums
         * @return {number}
         */

        // var singleNumber = function (nums) {
        //     let res = null
        //     let map = Object.create(null)
        //     nums.forEach(num => {
        //         if (map[num]) {
        //             item = map[num]
        //             item.count = item.count + 1
        //         } else {
        //             map[num] = {
        //                 count: 1,
        //                 val: num
        //             }
        //         }
        //     })
        //     console.log('map', map)
        //     Object.values(map).forEach(obj => {
        //         if (obj.count == 1) {
        //             res = obj.val
        //         }
        //     })
        //     return res

        // };

        // // Todo: 解题核心其余每一个元素都出现 2 次，多了也不行
        // var singleNumber = function (nums) {
        //     let ans = 0;
        //     for (const num of nums) {
        //         ans ^= num;
        //     }
        //     return ans;
        // };
        // console.log(singleNumber([4, 1, 2, 1, 2]))

        // // Todo: 二叉树中序续遍历 左 -> 根 -> 右
        // var inorderTraversal = function (root) {
        //     const res = [];
        //     const inorder = (root) => {
        //         if (!root) {
        //             return;
        //         }
        //         inorder(root.left);
        //         res.push(root.val);
        //         inorder(root.right);
        //     }
        //     inorder(root);
        //     return res;
        // };


        // Todo: 杨辉三角问题
        // https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked
        var generate = function (numRows) {
            const ret = [];
            for (let i = 0; i < numRows; i++) {
                const row = new Array(i + 1).fill(1);
                for (let j = 1; j < row.length - 1; j++) {
                    row[j] = ret[i - 1][j - 1] + ret[i - 1][j];
                }
                ret.push(row);
            }
            return ret;
        };









































    </script>

</body>

</html>