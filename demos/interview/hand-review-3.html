<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Todo: 最长回文串
        // 方法三：中心扩展法（最优解）
        // 思路：以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。
        // 时间复杂度：O(n²)。
        // 空间复杂度：O(1)。
        // function longestPalindrome(s) {
        //     let max = '';
        //     for (let i = 0; i < s.length; i++) {
        //         // 奇数长度回文（以s[i]为中心）
        //         const odd = expandAroundCenter(s, i, i);
        //         // 偶数长度回文（以s[i]和s[i+1]为中心）
        //         const even = expandAroundCenter(s, i, i + 1);
        //         // 更新最大值
        //         if (odd.length > max.length) max = odd;
        //         if (even.length > max.length) max = even;
        //     }
        //     return max;
        // }
        // function expandAroundCenter(s, left, right) {
        //     while (left >= 0 && right < s.length && s[left] === s[right]) {
        //         left--;
        //         right++;
        //     }
        //     return s.slice(left + 1, right); // 注意边界
        // }
        // console.log(longestPalindrome("babad")); // 输出 "bab" 或 "aba"


        // Todo: 质数因子
        // 180
        // function solution(num) {
        //     let res = [];
        //     let i = 2;
        //     while (i <= num && i * i <= num) {
        //         if (num % i === 0) {
        //             res.push(i);
        //             num = num / i;
        //             i = 2;
        //         } else {
        //             i++
        //         }
        //     }
        //     if (num !== 1) {
        //         res.push(i)
        //     }
        //     return res.join(' ');
        // }
        // console.log(solution(180))

        // let floatNum = readline();
        // let res = parseFloat(floatNum).toFixed(0)
        // console.log(res)


        // Todo: b是否是a的子集
        // a和b有重复元素，要求b的同个元素出现次数<=a的同个元素出现次数

        // function isSubset(a, b) {
        //     // 统计a中每个元素的出现次数
        //     const frequencyMap = {};
        //     for (const elem of a) {
        //         frequencyMap[elem] = frequencyMap[elem] ? frequencyMap[elem] + 1 : 1;
        //     }

        //     // 检查b中的每个元素是否都在a中且出现次数不超过
        //     for (const elem of b) {
        //         if (!frequencyMap[elem]) {
        //             return false;  // 元素不存在于a中
        //         }
        //         frequencyMap[elem]--;
        //         if (frequencyMap[elem] < 0) {
        //             return false;  // 元素出现次数超过a中的次数
        //         }
        //     }

        //     return true;
        // }

        // // 示例
        // const a = [1, 2, 2, 3, 4];
        // const b1 = [2, 2];  // 是子集
        // const b2 = [2, 2, 2];  // 不是子集（2出现3次 > a中的2次）

        // console.log(isSubset(a, b1)); // true
        // console.log(isSubset(a, b2)); // false

        // Todo: 将一串数组节点转化为二叉树
        function TreeNode(val, left, right) {
            this.val = (val === undefined ? 0 : val);
            this.left = (left === undefined ? null : left);
            this.right = (right === undefined ? null : right);
        }
        function arrayToTree(arr, index = 0) {
            if (index >= arr.length || arr[index] === null) {
                return null;
            }
            const node = new TreeNode(arr[index]);
            node.left = arrayToTree(arr, 2 * index + 1);  // 左子节点索引
            node.right = arrayToTree(arr, 2 * index + 2); // 右子节点索引
            return node;
        }
        // const arr = [1, 2, 3, 4, 5, 6, 7];
        // const root = arrayToTree(arr);
        // console.log(root);

        // Todo: 二叉树层序遍历 https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你二叉树的根节点 root ，返回其节点值的层序遍历 。 （即逐层地，从左到右访问所有节点）。
        // 输入：root = [3,9,20,null,null,15,7]
        // 输出：[[3],[9,20],[15,7]]
        // 示例 2：
        // 输入：root = [1]
        // 输出：[[1]]
        // 广度优先遍历

        let root = arrayToTree([3, 9, 20, null, null, 15, 7])

        // console.log('root', root)

        var levelOrder = function (root) {
            //二叉树的层序遍历
            let res = [], queue = [];
            queue.push(root);
            if (root === null) {
                return res;
            }
            while (queue.length !== 0) {
                // 记录当前层级节点数
                let length = queue.length;
                //存放每一层的节点 
                let curLevel = [];
                for (let i = 0; i < length; i++) {
                    let node = queue.shift(); // 取节点，存值，
                    curLevel.push(node.val);
                    // 存放当前层下一层的节点
                    node.left && queue.push(node.left);
                    node.right && queue.push(node.right);
                }
                //把每一层的结果放到结果数组
                res.push(curLevel);
            }
            return res;
        };

        console.log(levelOrder(root))


























    </script>

</body>

</html>