<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algo preview</title>
</head>

<body>
    <script>
        // Todo: 最长不重复子串
        // 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
        // 示例 1:
        // 输入: s = "abcabcbb"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
        // 示例 2:
        // 输入: s = "bbbbb"
        // 输出: 1
        // 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
        // 示例 3:
        // 输入: s = "pwwkew"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
        // 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

        // function solution(s) {
        //     let left = 0, maxLen = 0, char = new Set();
        //     for (let right = 0; right < s.length; right++) {
        //         while (char.has(s[right])) {
        //             char.delete(s[left])
        //             left++
        //         }
        //         char.add(s[right])
        //         maxLen = Math.max(maxLen, char.size)
        //     }
        //     return maxLen
        // }

        // console.log(solution("abcabcbb"))  // 3
        // console.log(solution("bbbbb"))     // 1
        // console.log(solution("pwwkew"))    // 3

        // Todo: 最长回文串
        // 给你一个字符串 s，找到 s 中最长的回文子串
        // 示例 1：
        // 输入：s = "babad"
        // 输出："bab"
        // 解释："aba" 同样是符合题意的答案。
        // 示例 2：
        // 输入：s = "cbbd"
        // 输出："bb"

        // function isPalindrome(s) {
        //     return s === s.split('').reverse().join('');
        // }

        // function isHuiWen(s, left, right) {
        //     while (left < right) {
        //         if (s[left] !== s[right]) {
        //             return false
        //         }
        //         left++
        //         right--
        //     }
        //     return true
        // }

        // function solution(s) {
        //     if (s.length < 2) {
        //         return s
        //     }
        //     let begin = 0, maxLen = 1
        //     for (let i = 0; i < s.length; i++) {
        //         for (let j = i+1; j < s.length; j++) {
        //             let currLen = j - i + 1
        //             if (currLen > maxLen && isHuiWen(s, i, j)) {
        //                 maxLen = currLen
        //                 begin = i
        //             }
        //         }
        //     }

        //     return String.prototype.substr.call(s, begin, maxLen)
        // }

        // console.log(solution("babad")) // bab 3
        // console.log(solution("cbbd"))  // bb 2

        // Todo: 冒泡排序：
        // 给定一个整数数组 nums，请你实现一个冒泡排序算法，将数组从小到大排序。
        // 输入: nums = [5, 2, 9, 1, 5, 6]
        // 输出: [1, 2, 5, 5, 6, 9]

        // function bubbleSort(nums) {
        //     for (let i = 0; i < nums.length; i++) {
        //         for (let k = 0; k < nums.length - i; k++) {
        //             if (nums[k] > nums[k + 1]) {
        //                 // let t = nums[k + 1]
        //                 // nums[k + 1] = nums[k]
        //                 // nums[k] = t
        //                 [nums[k + 1], nums[k]] = [nums[k], nums[k + 1]]
        //             }
        //         }
        //     }
        //     return nums
        // }
        // console.log(bubbleSort([5, 2, 9, 1, 5, 6]))

        // Todo: 三数之和
        // 给你一个整数数组 nums ，判断是否存在三元组[nums[i], nums[j], nums[k]]
        // 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。
        // 请你返回所有和为 0 且不重复的三元组。
        // 注意：答案中不可以包含重复的三元组。
        // const nums = [-1, 0, 1, 2, -1, -4];
        // 第一种解法：暴力破解，三层循环
        // 核心思想：先排序，确保三元组中，每一个元素的两两相邻不重复，即三元组不会重复。

        // function solution(nums) {
        //     let result = []
        //     nums.sort((a, b) => a - b)

        //     for (let i = 0; i < nums.length - 2; i++) {
        //         if (i > 1 && nums[i] === nums[i - 1]) {
        //             continue
        //         }
        //         for (let j = i + 1; j < nums.length - 1; j++) {
        //             if (j > i + 1 && nums[j] === nums[j - 1]) {
        //                 continue
        //             }
        //             for (let k = j + 1; k < nums.length; k++) {
        //                 if (k > j + 1 && nums[k] === nums[k - 1]) {
        //                     continue
        //                 }
        //                 if (nums[i] + nums[j] + nums[k] == 0) {
        //                     result.push([nums[i], nums[j], nums[k]])
        //                 }
        //             }
        //         }
        //     }
        //     return result
        // }

        // console.log(solution([-1, 0, 1, 2, -1, -4]))


        // Todo: 全排列
        // 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
        // 示例 1：
        // 输入：nums = [1, 2, 3]
        // 输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
        // 示例 2：
        // 输入：nums = [0, 1]
        // 输出：[[0, 1], [1, 0]]
        // 示例 3：
        // 输入：nums = [1]
        // 输出：[[1]]

        // function solution(nums) {
        //     let result = [], path = [], flags = []
        //     function backtracking(list, len, used) {
        //         if (path.length === len) {
        //             result.push([...path])
        //             return
        //         }
        //         for (let i = 0; i < len; i++) {
        //             if (used[i]) {
        //                 continue
        //             }
        //             used[i] = true
        //             path.push(list[i])
        //             backtracking(list, len, used)
        //             used[i] = false
        //             path.pop()
        //         }
        //     }
        //     backtracking(nums, nums.length, flags)
        //     return result
        // }

        // // 输入：nums = [1, 2, 3]
        // // 输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
        // console.log(solution([1, 2, 3]))

        // Todo: 快速排序
        // Tip: 快速排序的核心思想是什么呢？
        // 选取一个基准，然后比较，比它小的放左边，比它大的放右边
        // function quickSort(nums) {
        //     if (nums.length < 2) {
        //         return nums
        //     }
        //     let left = [], right = [], baseItem = nums[0]
        //     for (let i = 1; i < nums.length; i++) {
        //         if (nums[i] < baseItem) {
        //             left.push(nums[i])
        //         } else {
        //             right.push(nums[i])
        //         }
        //     }
        //     return [...quickSort(left), baseItem, ...quickSort(right)]
        // }
        // console.log(quickSort([7, 6, 2, 10, 9, 1, -3]))


        // Todo: 手写 bind
        // 返回一个函数，这个函数，
        // 1、作用域内部的this，指向 bind第一个参数，
        // 2、返回的函数，实参可以衔接之前bind第一个之后的所有参数
        // 核心思路 => 是将 hello.bind(me) => me.hello()
        // var name = 'test',
        // me = {
        //     name: 'zzy'
        // }

        // Function.prototype.MyBind = function () {
        //     const args = Array.from(arguments)
        //     const fn = this
        //     const context = args.slice(0, 1).pop()
        //     const remainingArgs = args.slice(1)

        //     const result = function () {
        //         const allArgs = remainingArgs.concat(Array.from(arguments))
        //         context.fn = fn
        //         context.fn(...allArgs)
        //         delete context.fn
        //     }
        //     return result
        // }
        // var name = 'test';
        // const me = {
        //     name: 'zzy'
        // }
        // function hello() {
        //     console.log('my name is: ', this.name)
        // }
        // hello()
        // hello.MyBind(me)()

        // Todo: 手写 new 操作符
        // new 主要完成了以下几个操作：
        // 创建一个空的对象。
        // 将该对象的 __proto__ 属性指向构造函数的 prototype。
        // 执行构造函数，将 this 指向该对象。

        // function MyNew(constructor, ...args) {
        //     const obj = {}
        //     obj.__proto__ = constructor.prototype
        //     const result = constructor.call(obj, ...args)

        //     return result instanceof Object ? result : obj;
        // }

        // // Todo: 手写防抖
        // function debounce(fn, delay = 300) {
        //     let timer
        //     return function(...args) {
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //         }, delay);
        //     }
        // }

        // // Todo: 手写节流
        // function throttle(fn, delay = 300) {
        //     let timer, isRunning = false;
        //     return function (...args) {
        //         if (isRunning) {
        //             return
        //         }
        //         isRunning = true
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //             isRunning = false
        //         }, delay);
        //     }
        // }

        // Todo: 寄生虫继承
        // function Parent(name) {
        //     this.name = name
        //     this.say()
        // }
        // Parent.prototype.say = function () {
        //     console.log('My name is ', this.name)
        // }
        // Parent.prototype.haha = function () {
        //     console.log(this.name)
        // }
        // function Child(name, age) {
        //     Parent.call(this, name)
        //     this.age = age
        // }
        // Child.prototype = Object.create(Parent.prototype)
        // const child1 = new Child('zzy')

        // Todo: 手写 setTimeout 模拟实现 setinterval
        // 1、 实现思路 setinterval 每隔一定的时间执行一个方法
        // function mySetinterval(fn, delay = 300) {
        //     let timer, isClear = false
        //     function innerInterval() {
        //         if (isClear) {
        //             isClear = false
        //             clearTimeout(timer)
        //             return
        //         }
        //         fn()
        //         timer = setTimeout(() => {
        //             innerInterval()
        //         }, delay);
        //     }
        //     timer = setTimeout(() => {
        //         innerInterval()
        //     }, delay);
        //     return () => {
        //         isClear = true
        //     }
        // }


        // Todo: 请求并发控制
        // class RequestController {
        //     constructor(limitNums) {
        //         this.limitNums = limitNums
        //         this.count = 0
        //         this.taskQueue = []
        //     }
        //     enqueue(requestFn) {
        //         return new Promise((resolve, reject) => {
        //             const task = function () {
        //                 this.count++
        //                 requestFn.then(resolve).catch(reject).finally(() => {
        //                     this.count--
        //                     this.dequeue()
        //                 })
        //             }
        //             this.taskQueue.push(task)
        //             this.dequeue()
        //         })
        //     }

        //     dequeue() {
        //         if (this.count < this.limitNums && this.taskQueue.length) {
        //             const task = this.taskQueue.shift()
        //             task()
        //         }
        //     }
        // }


        // class RequestController {
        //     constructor(limitNums) {
        //         this.limitNums = limitNums
        //         this.count = 0
        //         this.taskQueue = []
        //     }

        //     add(requestFn) {
        //         return new Promise((resolve, reject) => {
        //             this.taskQueue.push({
        //                 requestFn,
        //                 resolve,
        //                 reject
        //             })
        //             this.step()
        //         })
        //     }

        //     step() {
        //         while (this.count < this.limitNums && this.taskQueue.length) {
        //             const { requestFn,
        //                 resolve,
        //                 reject } = this.taskQueue.shift();
        //             this.count++
        //             requestFn.then(resolve).catch(reject).finally(() => {
        //                 this.count--
        //                 this.step()
        //             })
        //         }
        //     }

        //     remove(requestFn) {
        //         const index = this.queue.findIndex(item => item.requestFn == requestFn)
        //         if (index != -1) {
        //             this.queue.splice(index, 1)
        //         }
        //     }
        // }

        // Todo: 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
        // 有效字符串需满足：
        // 左括号必须用相同类型的右括号闭合。
        // 左括号必须以正确的顺序闭合。
        // 每个右括号都有一个对应的相同类型的左括号。
        // 示例 1：输入：s = "()"
        // 输出：true
        // 示例 2：
        // 输入：s = "()[]{}"
        // 输出：true
        // 示例 3：
        // 输入：s = "(]"
        // 输出：false
        // 示例 4：
        // 输入：s = "([])"
        // 输出：true

        // function solution(s) {
        //     const map = {
        //         "(": ")",
        //         "[": "]",
        //         "{": "}"
        //     }
        //     let stack = []
        //     for (let char of s) {
        //         if (map[char]) {
        //             stack.push(char)
        //         } else {
        //             let item = stack.pop()
        //             if (map[item] !== char) {
        //                 return false
        //             }
        //         }
        //     }
        //     return stack.length === 0
        // }
        // console.log(solution("()[]{}"))
        // console.log(solution("(]"))
        // console.log(solution("([])"))

        // Todo: 最长公共前缀
        // 编写一个函数来查找字符串数组中的最长公共前缀。
        // 如果不存在公共前缀，返回空字符串 ""。
        // 示例 1：
        // 输入：strs = ["flower","flow","flight"]
        // 输出："fl"
        // 示例 2：
        // 输入： strs = ["dog","racecar","car"]
        // 输出：""
        // 解释：输入不存在公共前缀。
        // function solution(strs) {
        //     if (strs.length <= 1) {
        //         return ''
        //     }
        //     let commonPrefix = strs[0]
        //     for (let i = 1; i < strs.length; i++) {
        //         let j = 0
        //         for (; j < strs[i].length && j < commonPrefix.length; j++) {
        //             if (commonPrefix[j] != strs[i][j]) {
        //                 break;
        //             }
        //         }
        //         commonPrefix = commonPrefix.substr(0, j)
        //     }
        //     return commonPrefix;
        // }

        // console.log(solution(["flower", "flow", "flight"]))
        // console.log(solution(["dog", "racecar", "car"]))

        // Todo:  https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked
        // 和为k的子数组
        // 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
        // 子数组是数组中元素的连续非空序列。
        // 示例 1：
        // 输入：nums = [1, 1, 1], k = 2
        // 输出：2
        // 示例 2：
        // 输入：nums = [1, 2, 3], k = 3
        // 输出：2
        // function solution(nums, k) {
        //     let count = 0, res = []
        //     for (let i = 0; i < nums.length; i++) {
        //         let sum = 0
        //         for (let j = i; j >= 0; j--) {
        //             sum += nums[j]
        //             if (sum == k) {
        //                 count += 1
        //                 let anwser = Array.from(nums).slice(j, i + 1)
        //                 console.log(anwser)
        //                 res.push(anwser)
        //             }
        //         }
        //     }
        //     return res
        // }
        // // console.log(solution([1, 1, 1], 2))
        // console.log(solution([1, 2, 3], 3))

        // Todo: 全排列
        // 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
        // 示例 1：
        // 输入：nums = [1, 2, 3]
        // 输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
        // 示例 2：
        // 输入：nums = [0, 1]
        // 输出：[[0, 1], [1, 0]]
        // 示例 3：
        // 输入：nums = [1]
        // 输出：[[1]]

        // function solution(nums) {
        //     let res = [], path = [];
        //     function backtracking(list, len, used) {
        //         if (path.length === len) {
        //             res.push(path.slice())
        //             return
        //         }
        //         for (let i = 0; i < list.length; i++) {
        //             if (used[i]) {
        //                 continue
        //             }
        //             used[i] = true
        //             path.push(list[i])
        //             backtracking(nums, nums.length, used)
        //             path.pop()
        //             used[i] = false
        //         }
        //     }
        //     backtracking(nums, nums.length, [])
        //     return res
        // }
        // console.log(solution([1, 2, 3]))

        // Todo: 49. 字母异位词分组
        // 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
        // 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
        // 示例 1:
        // 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
        // 输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

        // 示例 2:
        // 输入: strs = [""]
        // 输出: [[""]]
        // 示例 3:

        // 输入: strs = ["a"]
        // 输出: [["a"]]

        // 先处理key
        // 在map中寻找
        // 有则推进去

        // function solution(strs) {
        //     let map = new Map()
        //     for (let i = 0; i < strs.length; i++) {
        //         let strArr = strs[i].split('')
        //         strArr.sort()
        //         let key = strArr.toString()
        //         let list = map.get(key) ? map.get(key) : []
        //         list.push(strs[i])
        //         map.set(key, list)
        //     }
        //     return [...map.values()]
        // }
        // console.log(solution(["eat", "tea", "tan", "ate", "nat", "bat"]))


        // Todo: LRUCache
        // 什么是LRU，最近最少使用算法，来维护一个队列
        // 提供 put 方法 和 get 方法
        // put 方法：如果超过 capatiy，则 push 不进去
        // get 方法：获取到了，往前排；没有则返回 -1

        // LRU（Least Recently Used，最近最少使用）算法是一种常用的缓存淘汰策略，广泛应用于操作系统、数据库、缓存系统（如Redis、Memcached）以及前端开发中。其核心思想是：当缓存空间不足时，优先淘汰最久未被使用的数据。
        // LRU算法的核心思想
        // 最近使用原则：
        // 如果一个数据最近被访问过，那么它在未来被访问的概率也较高。
        // 如果一个数据很久没有被访问，那么它在未来被访问的概率较低，可以优先淘汰。
        // 淘汰策略：
        // 当缓存空间不足时，淘汰最久未被访问的数据。

        // class LRUCache {
        //     constructor(capacity) {
        //         this.capacity = capacity
        //         this.map = new Map()
        //     }
        //     get(key) {
        //         if (this.map.has(key)) {
        //             const item = this.map.get(key)
        //             this.map.delete(key)
        //             this.map.set(key, item)
        //             return item
        //         } else {
        //             return -1
        //         }
        //     }

        //     put(key, item) {
        //         // 判断 key 是否存在
        //         if (this.map.has(key)) {
        //             this.map.delete(key)
        //         }
        //         this.map.set(key, item)
        //         if (this.map.size > this.capacity) {
        //             // 拿到刚刚插入的key，之后删除最先 this.map 最前面的 key
        //             const firstKey = this.map.keys().next().value
        //             this.map.delete(firstKey)
        //         }
        //     }
        // }

        // let lRUCache = new LRUCache(2);
        // lRUCache.put(1, 1);  // 缓存是 {1=1}
        // lRUCache.put(2, 2);  // 缓存是 {1=1, 2=2}
        // console.log('lRUCache', lRUCache)

        // console.log(lRUCache.get(1));     // 返回 1
        // lRUCache.put(3, 3);  // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
        // console.log(lRUCache.get(2));     // 返回 -1


        // Todo: 最长不重复子串
        // 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
        // 示例 1:
        // 输入: s = "abcabcbb"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
        // 示例 2:
        // 输入: s = "bbbbb"
        // 输出: 1
        // 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
        // 示例 3:
        // 输入: s = "pwwkew"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
        // 请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
        // function solution(s) {
        //     let maxLen = 0, left = 0, charSet = new Set();
        //     for (let right = 0; right < s.length; right++) {
        //         while (charSet.has(s[right])) {
        //             charSet.delete(s[left])
        //             left++
        //         }
        //         charSet.add(s[right])
        //         maxLen = Math.max(maxLen, charSet.size)
        //     }
        //     return maxLen
        // }
        // console.log(solution("abcabcbb"))
        // console.log(solution("bbbbb"))
        // console.log(solution("pwwkew"))


        // Todo: 49. 字母异位词分组
        // 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
        // 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
        // 示例 1:
        // 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
        // 输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
        // 示例 2:
        // 输入: strs = [""]
        // 输出: [[""]]
        // 示例 3:
        // 输入: strs = ["a"]
        // 输出: [["a"]]

        // 解题思路：字母排序时候，key是一样的，以此来统计分组
        // function solution(strs) {
        //     const map = new Map()
        //     for (let i = 0; i < strs.length; i++) {
        //         let str = strs[i]
        //         let strArr = str.split('')
        //         strArr.sort()
        //         let key = strArr.toString()
        //         let list = map.get(key) ? map.get(key) : []
        //         list.push(str)
        //         map.set(key, list)
        //     }
        //     return [...map.values()]
        // }
        // console.log(solution(["eat", "tea", "tan", "ate", "nat", "bat"]))


        // Todo: 二叉树相关
        // 将数组转为二叉树

        class TreeNode {
            constructor(val, left, right) {
                this.val = val === undefined ? 0 : val
                this.left = left === undefined ? null : left
                this.right = right === undefined ? null : right
            }
        }

        function arrayToTree(arr, index = 0) {
            if (index >= arr.length || arr[index] === null) {
                return null
            }
            let node = new TreeNode(arr[index])
            node.left = arrayToTree(arr, 2 * index + 1)
            node.right = arrayToTree(arr, 2 * index + 2)
            return node
        }
        let arr = [1, 2, 3, 4, 5, 6, 7, 8]

        // console.log(arrayToTree(arr))
        // Todo: 二叉树 层序遍历 BFS，
        // 输出每一层的节点
        function solutionBFS(root) {
            let res = [], queue = []
            if (root === null) {
                return res
            }
            queue.push(root)
            while (queue.length) {
                let length = queue.length // 记录当前层的 length
                let currentLevel = []
                for (let i = 0; i < length; i++) {
                    let node = queue.shift()
                    node.val && currentLevel.push(node.val)
                    node.left && queue.push(node.left)
                    node.right && queue.push(node.right)
                }
                res.push(currentLevel)
            }
            return res
        }
        // console.log(solutionBFS(arrayToTree(arr)))
        // Todo: 二叉树 层序遍历 BFS，输出非叶子结点
        // 
        // function solutionLeafBFS(root) {
        //     let res = [], queue = []
        //     if (root === null) {
        //         return res
        //     }
        //     queue.push(root)
        //     while (queue.length) {
        //         let length = queue.length // 记录当前层的 length
        //         for (let i = 0; i < length; i++) {
        //             let node = queue.shift()
        //             if (node.left || node.right) {
        //                 res.push(node.val)
        //             }
        //             node.left && queue.push(node.left)
        //             node.right && queue.push(node.right)
        //         }

        //     }
        //     return res
        // }
        // console.log(solutionLeafBFS(arrayToTree(arr))) 
        // [1, 2, 3, 4]

        function solutionLeafDFS(root) {
            let res = []

            function dfs(node) {
                if (node === null) {
                    return
                }
                if (node.left || node.right) {
                    res.push(node.val)
                }
                dfs(node.left)
                dfs(node.right)
            }

            dfs(root)
            return res
        }

        console.log(solutionLeafDFS(arrayToTree(arr)))
        //  [1, 2, 4, 3]

        // Todo: 如何保证输出的顺序，左 -> 右 -> 根 
        

































































    </script>

</body>

</html>