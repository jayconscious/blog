<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algo-practice-9-14</title>
</head>

<body>
    <script>
        // Todo: 438. 找到字符串中所有字母异位词
        // 滑动窗口
        // 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

        // 示例 1:
        // 输入: s = "cbaebabacd", p = "abc"
        // 输出: [0,6]
        // 解释:
        // 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
        // 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

        // 示例 2:
        // 输入: s = "abab", p = "ab"
        // 输出: [0,1,2]
        // 解释:
        // 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
        // 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
        // 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

        // 核心思路是啥：遍历s，截取 p 长度相同的字符串，看看是否是相同的字符串。

        //
        // function isSameStr(str1, str2) {
        //     let str1Sorted = str1.split('').sort().join('')
        //     let str2Sorted = str2.split('').sort().join('')
        //     return str1Sorted == str2Sorted
        // }

        // function solution(s, p) {
        //     let result = [];
        //     if (s.length < p.length) {
        //         return result
        //     }
        //     for (let i = 0; i < s.length; i++) {
        //         const element = s[i]
        //         if (p.indexOf(element) != -1) {
        //             let currStr = s.substr(i, p.length)
        //             let flag = isSameStr(currStr, p)
        //             if (flag) {
        //                 result.push(i)
        //             }
        //         }
        //     }
        //     return result
        // }

        // 第二种：滑动窗口
        // 在 s 中统计与 p.length 相同的字符串频次是否相同，然后开始窗口滑动，统计所有的情况。

        // const solution = function (s, p) {
        //     let sLen = s.length, pLen = p.length, result = []
        //     if (sLen < pLen) {
        //         return []
        //     }

        //     let sCount = new Array(26).fill(0)
        //     let pCount = new Array(26).fill(0)

        //     for (let i = 0; i < pLen.length; i++) {
        //         sCount[s[i].charCodeAt() - 'a'.charCodeAt()]++
        //         pCount[p[i].charCodeAt() - 'a'.charCodeAt()]++
        //     }

        //     if (sCount.toString() == pCount.toString()) {
        //         result.push(0)
        //     }

        //     for (let i = 0; i < sLen - pLen; i++) {
        //         sCount[s[i].charCodeAt() - 'a'.charCodeAt()]--
        //         sCount[s[i + pLen].charCodeAt() - 'a'.charCodeAt()]++
        //         if (sCount.toString() == pCount.toString()) {
        //             result.push(i + 1)
        //         }
        //     }
        //     return result
        // }


        // console.log(solution("cbaebabacd", "abc"))
        // console.log(solution("abab", "ab"))


        // Todo: 238. 除自身以外数组的乘积 - 普通数组
        // 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

        // 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
        // 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

        // 示例 1:
        // 输入: nums = [1,2,3,4]
        // 输出: [24,12,8,6]

        // 示例 2:
        // 输入: nums = [-1,1,0,-3,3]
        // 输出: [0,0,9,0,0]

        // 第一种方法：
        // var productExceptSelf = function (nums) {
        //     let result = []
        //     for (let i = 0; i < nums.length; i++) {
        //         const currEle = nums[i]
        //         const copyNums = [...nums]
        //         copyNums.splice(i, 1)
        //         const newNum = caculateNum(copyNums)
        //         // console.log('newNum', newNum)
        //         result.push(newNum)
        //     }
        //     return result
        // };

        // const caculateNum = function (nums) {
        //     if (nums.length === 0) return 0; // 或者 return 1，根据需求决定
        //     return nums.reduce((acc, num) => acc * num, 1);
        // }


        // 第二种方法：

        // console.log(productExceptSelf([1, 2, 3, 4]))

        // Todo: tuozhu 面试题
        // 



    </script>
</body>

</html>