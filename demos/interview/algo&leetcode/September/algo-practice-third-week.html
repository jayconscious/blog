<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algo-practice-9-15</title>
</head>

<body>
    <script>
        // Todo: 238. 除自身以外数组的乘积 - 普通数组
        // 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

        // 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
        // Tip: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

        // 示例 1:
        // 输入: nums = [1,2,3,4]
        // 输出: [24,12,8,6]

        // 示例 2:
        // 输入: nums = [-1,1,0,-3,3]
        // 输出: [0,0,9,0,0]

        // 第一种方法：
        // var productExceptSelf = function (nums) {
        //     let result = []
        //     for (let i = 0; i < nums.length; i++) {
        //         const currEle = nums[i]
        //         const copyNums = [...nums]
        //         copyNums.splice(i, 1)
        //         const newNum = caculateNum(copyNums)
        //         // console.log('newNum', newNum)
        //         result.push(newNum)
        //     }
        //     return result
        // };

        // const caculateNum = function (nums) {
        //     if (nums.length === 0) return 0; // 或者 return 1，根据需求决定
        //     return nums.reduce((acc, num) => acc * num, 1);
        // }

        // 第二种方法：使用左右乘积法

        // function productExceptSelf(nums) {
        //     const length = nums.length
        //     let L = new Array(length)
        //     let R = new Array(length)
        //     let answer = new Array(length)
        //     L[0] = 1;
        //     for (let i = 1; i < length; i++) {
        //         L[i] = nums[i - 1] * L[i - 1];
        //     }
        //     R[length - 1] = 1
        //     for (let i = length - 2; i >= 0; i--) {
        //         R[i] = R[i + 1] * nums[i + 1]
        //     }
        //     console.log('L', L)
        //     console.log('R', R)
        //     for (let i = 0; i < length; i++) {
        //         answer[i] = L[i] * R[i]
        //     }
        //     return answer
        // }
        // // console.log(productExceptSelf([1, 2, 3, 4]))
        // // console.log(productExceptSelf([-1, 1, 0, -3, 3]))
        // console.log(productExceptSelf([4, 5, 1, 8, 2]))

        // Todo: tuozhu 面试题
        // 统计js最大调用栈
        // 自己最开始的想法：
        // function getMaxCallStackSize() {
        //     let count = 1
        //     function inner() {
        //         count++
        //         try {
        //             return inner()
        //         } catch (error) {
        //             return count
        //         }
        //     }
        //     return inner()
        // }

        // function getMaxCallStackSize() {
        //     let count = 0
        //     function inner() {
        //         count++
        //         inner()
        //     }
        //     try {
        //         inner()
        //     } catch (error) {
        //         return count
        //     }
        // }

        // 最优解：
        // function getMaxCallStackSize() {
        //     try {
        //         return 1 + getMaxCallStackSize(); // 递归累加
        //     } catch (e) {
        //         // 栈溢出时返回当前深度
        //         return 1;
        //     }
        // }
        // 注意：执行此函数会导致栈溢出错误，建议仅在测试环境运行！
        // console.log("最大调用栈大小:", getMaxCallStackSize());

        // Tip: 关注点
        // 第一种思维（命令式）    第二种思维（函数式）
        // 关注"怎么做"	        关注"做什么"
        // 使用可变状态	        使用不可变数据
        // 循环和迭代	            递归和组合
        // 修改外部变量	        通过返回值传递状态
        // 副作用	               纯函数


        // Todo: 54. 螺旋矩阵 https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked
        // 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
        // 例1：
        // 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
        // 输出：[1,2,3,6,9,8,7,4,5]
        // 例2：
        // 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
        // 输出：[1,2,3,4,8,12,11,10,9,5,6,7]

        // 可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。
        // 判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
        // 如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

        function spiralOrder(matrix) {
            if (!matrix.length || !matrix[0].length) {
                return []
            }

            const rows = matrix.length, columns = matrix[0].length
            const visited = new Array(rows).fill(0).map(() => new Array(columns).fill(false))
            const total = columns * rows
            const order = new Array(total).fill(0)

            let directionIndex = 0, row = 0, column = 0;
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

            for (let i = 0; i < total; i++) {
                order[i] = matrix[row][column];
                visited[row][column] = true;

                const nextRow = row + directions[directionIndex][0];
                const nextColumn = column + directions[directionIndex][1];

                if (!(0 <= nextRow && nextRow < rows && 0 <= nextColumn && nextColumn < columns && !(visited[nextRow][nextColumn]))) {
                    directionIndex = (directionIndex + 1) % 4;
                }

                row += directions[directionIndex][0];
                column += directions[directionIndex][1];
            }
            return order;
        }

        // Todo: 




    </script>
</body>

</html>