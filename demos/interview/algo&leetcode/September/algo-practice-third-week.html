<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algo-practice-9-15</title>
</head>

<body>
    <script>
        // Todo: 238. 除自身以外数组的乘积 - 普通数组
        // 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

        // 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
        // Tip: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

        // 示例 1:
        // 输入: nums = [1,2,3,4]
        // 输出: [24,12,8,6]

        // 示例 2:
        // 输入: nums = [-1,1,0,-3,3]
        // 输出: [0,0,9,0,0]

        // 第一种方法：
        // var productExceptSelf = function (nums) {
        //     let result = []
        //     for (let i = 0; i < nums.length; i++) {
        //         const currEle = nums[i]
        //         const copyNums = [...nums]
        //         copyNums.splice(i, 1)
        //         const newNum = caculateNum(copyNums)
        //         // console.log('newNum', newNum)
        //         result.push(newNum)
        //     }
        //     return result
        // };

        // const caculateNum = function (nums) {
        //     if (nums.length === 0) return 0; // 或者 return 1，根据需求决定
        //     return nums.reduce((acc, num) => acc * num, 1);
        // }

        // 第二种方法：使用左右乘积法

        // function productExceptSelf(nums) {
        //     const length = nums.length
        //     let L = new Array(length)
        //     let R = new Array(length)
        //     let answer = new Array(length)
        //     L[0] = 1;
        //     for (let i = 1; i < length; i++) {
        //         L[i] = nums[i - 1] * L[i - 1];
        //     }
        //     R[length - 1] = 1
        //     for (let i = length - 2; i >= 0; i--) {
        //         R[i] = R[i + 1] * nums[i + 1]
        //     }
        //     console.log('L', L)
        //     console.log('R', R)
        //     for (let i = 0; i < length; i++) {
        //         answer[i] = L[i] * R[i]
        //     }
        //     return answer
        // }
        // // console.log(productExceptSelf([1, 2, 3, 4]))
        // // console.log(productExceptSelf([-1, 1, 0, -3, 3]))
        // console.log(productExceptSelf([4, 5, 1, 8, 2]))

        // Todo: tuozhu 面试题
        // 统计js最大调用栈
        // 自己最开始的想法：
        function getMaxCallStackSize() {
            let count = 1
            function inner() {
                count++
                try {
                    return inner()
                } catch (error) {
                    return count
                }
            }
            return inner()
        }

        function getMaxCallStackSize() {
            let count = 0
            function inner() {
                count++
                inner()
            }
            try {
                inner()
            } catch (error) {
                return count
            }
        }

        // 最优解：
        // function getMaxCallStackSize() {
        //     try {
        //         return 1 + getMaxCallStackSize(); // 递归累加
        //     } catch (e) {
        //         // 栈溢出时返回当前深度
        //         return 1;
        //     }
        // }
        // 注意：执行此函数会导致栈溢出错误，建议仅在测试环境运行！
        // console.log("最大调用栈大小:", getMaxCallStackSize());

        // Tip: 关注点
        // 第一种思维（命令式）    第二种思维（函数式）
        // 关注"怎么做"	        关注"做什么"
        // 使用可变状态	        使用不可变数据
        // 循环和迭代	            递归和组合
        // 修改外部变量	        通过返回值传递状态
        // 副作用	               纯函数

        // 



    </script>
</body>

</html>