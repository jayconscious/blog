<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algo-practice-8-21</title>
</head>

<body>
    <script>
        // Todo: 438. 找到字符串中所有字母异位词
        // 滑动窗口
        // 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

        // 示例 1:
        // 输入: s = "cbaebabacd", p = "abc"
        // 输出: [0,6]
        // 解释:
        // 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
        // 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

        // 示例 2:
        // 输入: s = "abab", p = "ab"
        // 输出: [0,1,2]
        // 解释:
        // 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
        // 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
        // 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

        // 核心思路是啥：遍历s，截取 p 长度相同的字符串，看看是否是相同的字符串。

        /**
         * @param {string} s
         * @param {string} p
         * @return {number[]}
         */
        // 第一种：
        // const toSameStr = function (s) {
        //     return s.split('').sort().join('')
        // }

        // var findAnagrams = function (s, p) {
        //     let result = [];
        //     for (let i = 0; i < s.length; i++) {
        //         const currStr = s.slice(i, i + p.length)
        //         if (toSameStr(currStr) == toSameStr(p)) {
        //             result.push(i)
        //         }
        //     }
        //     return result
        // };

        // console.log(findAnagrams("cbaebabacd", "abc"))

        // 第二种：滑动窗口
        // 核心思路是啊？
        // 统计与p.length 相同的字符串频次是否相同，然后开始窗口滑动，统计所有的情况。

        var findAnagrams = function (s, p) {
            const sLen = s.length, pLen = p.length;

            if (sLen < pLen) {
                return [];
            }

            const ans = [];
            const sCount = new Array(26).fill(0);
            const pCount = new Array(26).fill(0);
            
            // 取 p 长度的字符串，统计这个字符串的频率和p是否相同
            for (let i = 0; i < pLen; ++i) {
                ++sCount[s[i].charCodeAt() - 'a'.charCodeAt()];
                ++pCount[p[i].charCodeAt() - 'a'.charCodeAt()];
            }
            
            // console.log('sCount', sCount)
            // console.log('pCount', pCount)

            if (sCount.toString() === pCount.toString()) {
                ans.push(0);
            }

            for (let i = 0; i < sLen - pLen; ++i) {
                --sCount[s[i].charCodeAt() - 'a'.charCodeAt()];
                ++sCount[s[i + pLen].charCodeAt() - 'a'.charCodeAt()];

                if (sCount.toString() === pCount.toString()) {
                    ans.push(i + 1);
                }
            }

            return ans;
        };

        // console.log(findAnagrams("cbaebabacd", "abc"))
        console.log(findAnagrams("eba", "abc"))


        // https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked
        // Todo: 轮转数组
        // 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
        // 要求是原地修改数组

        // 示例 1:
        // 输入: nums = [1,2,3,4,5,6,7], k = 3
        // 输出: [5,6,7,1,2,3,4]
        // 解释:
        // 向右轮转 1 步: [7,1,2,3,4,5,6]
        // 向右轮转 2 步: [6,7,1,2,3,4,5]
        // 向右轮转 3 步: [5,6,7,1,2,3,4]

        // 示例 2:
        // 输入：nums = [-1,-100,3,99], k = 2
        // 输出：[3,99,-1,-100]
        // 解释: 
        // 向右轮转 1 步: [99,-1,-100,3]
        // 向右轮转 2 步: [3,99,-1,-100]

        // var rotate = function(nums, k) {

        //     for (let i = 0; i < k; i++) {
        //         const endNum = nums.pop()
        //         nums.unshift(endNum)
        //     }

        //     return nums
        // };

        // var rotate = function (nums, k) {
        //     const n = nums.length;
        //     k = k % n;
        //     if (k === 0) return;
        //     // 使用 splice 和 unshift 原地修改
        //     const rotatedPart = nums.splice(n - k);
        //     nums.unshift(...rotatedPart);
        // };
        // console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3))


        









    </script>
</body>

</html>