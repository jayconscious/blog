<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // Todo: 手写 bind
        // 返回一个函数，这个函数，
        // 1、作用域内部的this，指向 bind第一个参数，
        // 2、返回的函数，实参可以衔接之前bind第一个之后的所有参数
        // 核心思路 => 是将 hello.bind(me) => me.hello()
        // var name = 'test',
        // me = {
        //     name: 'zzy'
        // }
        // Function.prototype.myBind = function () {
        //     const argsArr = Array.from(arguments)
        //     const context = argsArr.slice(0, 1).shift()
        //     const restArgs = argsArr.slice(1)
        //     const fn = this
        //     const result = function () {
        //         const argsList = restArgs.concat(Array.from(arguments).slice())
        //         context.fn = fn
        //         context.fn(...argsList)
        //         delete context.fn
        //     }
        //     // Todo: 继承原函数的原型链
        //     result.prototype = Object.create(this.prototype)
        //     return result
        // }
        // function hello () { 
        //     console.log('my name is: ', this.name)
        // }
        // // hello()
        // // hello.myBind(me)()

        // // Todo: 手写 bind 实现
        // // 返回一个函数，这个函数
        // // this 指向问题，以弱绑定的方式去实现强绑定
        // // 例如
        // var name = 'wahaha'
        // function helloName (age) {
        //     console.log(this?.name, ' and age is ', age)
        // }
        // // helloName()
        // const you = {
        //     name: 'gpt-4'
        // }
        // helloName.bind(you)(18)
        // 解题思路：将 helloName.bind(you)() => you.helloName() 执行
        // 1：拿到 context
        // 2：绑定
        // 连接参数的能力
        // 3：执行
        // 4：删除
        // Function.prototype.meBind = function () {
        //     const argsArr = Array.from(arguments)
        //     const context = argsArr.slice(0, 1).shift()
        //     const remainingArgs = argsArr.slice(1)
        //     const fn = this
        //     const returnFn = function () {
        //         context.fn = fn
        //         const otherArgs = Array.from(arguments)
        //         const allArgs = remingArgs.concat(otherArgs)
        //         context.fn(...allArgs)
        //         // Todo: 继承原函数的原型链
        //         returnFn.prototype = Object.create(this.prototype)
        //         delete context.fn
        //     }
        //     return returnFn
        // }
        // helloName.meBind(you)(11)


        // Todo: 手写 Promise 实现，.then()方法，.all()方法

        // const request = function () {
        //     setTimeout(() => {
        //         console.log('request end')
        //     }, 2000);
        // }
        // request()

        // const request = function () {
        //     return new Promise(function(resolve, reject) {
        //         setTimeout(() => {
        //             console.log('request end')
        //             resolve()
        //         }, 2000);
        //     })
        // }
        // request().then(() => console.log('111'))

        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     // 异步执行的情况
        //     if (this.status === 'pending') {
        //         if (onFulfilled) {
        //             this.successList.push(() => onFulfilled(this.res))
        //         }
        //         if (onRejected) {
        //             this.failedList.push(() => onRejected(this.error))
        //         }
        //     }
        //     // 同步的话呢?
        //     if (this.status === 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.res))
        //     }
        //     if (this.status === 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.error))
        //     }
        // }

        // 问题是啥？能支持异步调用吗？
        // 利用 eventLoop 就可以做到。将要执行的函数保存到 list 当中
        // new MyPromise(function(resolve, reject) {
        //   setTimeout(function() {
        //     resolve('hello world~')
        //   }, 2000)
        // }).then(res => {  
        //   console.log(res)
        //   return 'asdas'
        // })


        // 链式调用？
        // new Promise(fn).then().then()
        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new MyPromise(function (resolve, rejected) {
        //         // 异步执行的情况
        //         if (that.status === 'pending') {
        //             if (onFulfilled) {
        //                 that.successList.push(() => {
        //                     setTimeout(() => {
        //                         console.log('that', that)
        //                         let x = onFulfilled(that.res)
        //                         // x 的返回值，
        //                         // 可能是 promise, 
        //                         // 也可能是普通对象
        //                         // 需要判断循环引用吗？
        //                         resolvePromise(p2, x, resolve, rejected)
        //                     }, 0);
        //                 })

        //             }
        //             if (onRejected) {
        //                 that.failedList.push(() => {
        //                     setTimeout(() => {
        //                         onRejected(that.error)
        //                     }, 0);
        //                 })
        //             }
        //         }
        //         // 同步的话呢?
        //         if (that.status === 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 setTimeout(() => {
        //                     onFulfilled(that.res)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status === 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     onRejected(that.error)
        //                 }, 0);
        //             })
        //         }
        //     })
        //     return p2
        // }

        // // 判断，第一个 then 中，onFulfilled 执行的返回结果是啥。
        // function resolvePromise(p2, x, resolve, reject) {
        //     // 
        //     if (p2 === x) {
        //         return reject('erro')
        //     }
        //     if (x !== null && (typeof x == 'object' || typeof x == 'function')) {
        //         let called = false
        //         // 不用开关控制的结果是什么？
        //         try {
        //             let then = x.then
        //             if (typeof then == 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, err => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // class MyPromise {
        //     constructor(executor) {
        //         this.status = 'pending'
        //         this.value = ''
        //         this.error = ''
        //         this.resolveQueue = []
        //         this.rejectQueue = []
        //         const resolve = res => {
        //             if (this.status === 'pending') {
        //                 this.status = 'fulfilled'
        //                 this.value = res
        //                 this.resolveQueue.forEach(fn => fn())
        //             }
        //         }
        //         const reject = err => {
        //             if (this.status === 'pending') {
        //                 this.status = 'rejected'
        //                 this.error = err
        //                 this.rejectQueue.forEach(fn => fn())
        //             }
        //         }
        //         executor(resolve, reject)
        //     }
        //     // 偶有的函数执行都是在resolve 这一步做的
        //     then(onFulfilled, onRejected) {
        //         let promise2
        //         promise2 = new Promise((resolve, reject) => {
        //             if (this.status === 'pending') {
        //                 // 这个回调函数的这行有多种可能性, 还有在写 onFulfilled/onRejected 必须要 return 这个值x
        //                 // 1. x = 普通对象
        //                 // 2. x = promise对象
        //                 this.resolveQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onFulfilled(this.value)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })
        //                 this.rejectQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onRejected(this.error)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })

        //             }
        //             // 前一个promise的状态已经改变就不需要 Push 了
        //             if (this.status === "fulfilled") {
        //                 setTimeout(() => {
        //                     let x = onFullfilled(this.value)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //             if (this.status === "rejected") {
        //                 setTimeout(() => {
        //                     let x = onRejected(this.error)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //         })
        //         return promise2
        //     }
        // }

        // new MyPromise(function (resolve, reject) {
        //     setTimeout(function () {
        //         resolve('hello world~')
        //     }, 2000)
        // }).then(res => {
        //     console.log(res)
        //     return 'asdas'
        // }).then(res => {
        //     console.log(res)
        // })

        // 链式调用

        // MyPromise.all = function (promiseList = []) {
        //     let count = 0, len = promiseList.length, resultList = []
        //     return new MyPromise(function (resolve, reject) {
        //         for (let index = 0; index < len; index++) {
        //             const element = array[index];
        //             element.then(res => {
        //                 count++
        //                 resultList.push(res)
        //                 if (resultList.len === count) {
        //                     resolve(resultList)
        //                 } else {
        //                     reject()
        //                 }
        //             })
        //         }
        //     })
        // }
        // // catch
        // MyPromise.prototype.catch = function (onRejected) {
        //     return this.then(null, onRejected)
        //     // ...
        // }
        // // resolve
        // MyPromise.resolve = function (res) {
        //     return new MyPromise((resolve, reject) => {
        //         resolve(res)
        //     })
        // }

        // x 是 onFulfilled 的返回
        // 要去判断 x 到底是什么情况？
        // function resolvePromise(p2, x, resolve, reject) {
        //     if (p2 === x) {
        //         return reject('error')
        //     }
        //     let called = false
        //     if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
        //         try {
        //              // 依据 promise A+ 规范，x 为 promise
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, (err) => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }


        // 手写 Promise 实现
        // Promise 解决了什么问题？
        // 解决了，由于js单线程的异步回调特性-解决代码的结构的异步回调地狱的问题。
        // 内部有三种状态， pending ， fulfilled ，rejected 。初始态是 pending，成功fulfilled，
        // 失败 rejected，状态一旦发生切换，就是不可改变的。
        // function FakePromise(executor) {
        //     this.status = 'pending'
        //     this.value = ''
        //     this.error = ''
        //     this.failedList = []
        //     this.successList = []
        //     const resolve = (value) => {
        //         if (this.status == 'pending') {
        //             this.status == 'fulfilled'
        //             this.value = value
        //             this.successList.forEach(cb => cb())
        //         }
        //     }
        //     const reject = (err) => {
        //         if (this.status == 'pending') {
        //             this.status == 'rejected'
        //             this.error = err
        //             this.failedList.forEach(cb => cb())
        //         }
        //     }

        //     try {
        //         executor(resolve, reject)
        //     } catch (error) {

        //     }
        // }
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     if (this.status == 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //     }
        //     if (this.status == 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        //     if (this.status == 'pending') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        // }

        // 简易实现
        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve()
        //     }, 2000);
        // }).then(() => console.log('111'))

        // 实现 then 的链式调用
        // 
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new FakePromise(function (resolve, reject) {
        //         if (that.status == 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //         // 思考问题：then的链式调用取决于什么？
        //         // 1、在第一个 then 之后返回一个promise 对象
        //         // 2、resolve 之后 才可以持续调用是吧？那么什么时候才可以 resolve 呢？
        //         // 3、这要去判断 第一个 then中 onFulfilled 值的返回情况
        //         if (this.status == 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     let x = onRejected(that.value)
        //                     resolvePromise(p2, x, resolve, reject)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status == 'pending') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //             onRejected && that.failedList.push(() => {
        //                 let x = onRejected(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //     })
        //     return p2
        // }

        // function resolvePromise(p2, x, resolve, reject) {
        //     // 排除循环引用的 case
        //     if (p2 === x) {
        //         reject(new Error('exist cycle ...'))
        //     }
        //     if (x !== null && (typeof x === 'function' || typeof x === 'object')) {
        //         let called = false
        //         try {
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) {
        //                         return
        //                     }
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }
        //                     , err => {
        //                         if (called) {
        //                             return
        //                         }
        //                         called = true
        //                         reject(err)
        //                     })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) {
        //                 return
        //             }
        //             called = true
        //             reject(err)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve('111')
        //     }, 2000);
        // }).then(res => {
        //     console.log('then 1 res', res)
        //     return 'second p2'
        // }).then((res) => {
        //     console.log('then 2 res', res)
        // })

        // Todo: 手写寄生虫组合 继承
        // 面向对象编程，解决的问题是啥？
        // 封装，继承，多态

        // function Parent (name) {
        //     this.name = name
        //     this.say()
        // }

        // Parent.prototype.say = function () {
        //     console.log('My name is ', this.name)
        // }
        // new Parent('zgy')

        // function Son(name) {
        //     Parent.call(this, name)
        // }
        // Son.prototype = Object.create(Parent.prototype)
        // new Son('zzy')

        // Todo: 手写 new 操作符
        // new 主要完成了以下几个操作：
        // 创建一个空的对象。
        // 将该对象的 __proto__ 属性指向构造函数的 prototype。
        // 执行构造函数，将 this 指向该对象。

        // 如果构造函数没有显式返回对象，默认返回新创建的对象。

        // function myNew(constructor, ...args) {
        //     // 1
        //     // const obj = Object.create(ClassFn.prototype)

        //     const obj = {}
        //     obj.__proto__ = constructor.prototype
        //     const result = constructor.call(obj, ...args)

        //     return result instanceof Object ? result : obj;
        // }

        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        // }
        // Person.prototype.sayHello = function () {
        //     console.log(`Hello, my name is ${this.name}, and I am ${this.age} years old.`);
        // };
        // // 使用 myNew 来模拟 new 操作符
        // const person1 = myNew(Person, 'Alice', 25);
        // person1.sayHello();


        // Todo: 手写 setTimeout 模拟实现 setinterval
        // 思路是啥？
        // 在延时器内部调用延时器

        // function mySetInternal(fn, time = 100) {
        //     let timer, isClear = false
        //     function interval() {
        //         if (isClear) {
        //             isClear = false
        //             clearTimeout(timer)
        //             return
        //         }
        //         fn()
        //         timer = setTimeout(interval, time);
        //     }
        //     timer = setTimeout(interval, time);
        //     return () => {
        //         isClear = true
        //     }
        // }

        // Todo: 手写-发布订阅模式 EventEmitter 实现

        // class EventEmitter {
        //     constructor() {
        //         this.eventMap = Object.create(null)
        //     }
        //     on(eventType, fn) {
        //         // 第一步：检测是否存在，不存在则初始化
        //         if (!this.eventMap[eventType]) {
        //             this.eventMap[eventType] = []
        //         }
        //         // 第一步：赋值
        //         this.eventMap[eventType].push(fn)
        //     }
        //     remove(eventType, fn) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType] = this.eventMap[eventType].filter(cb => cb != fn)
        //         }
        //     }
        //     once(eventType, fn) {
        //         const cb = () => {
        //             fn()
        //             this.remove(eventType)
        //         }
        //         this.on(eventType, cb)
        //     }

        //     emit(eventType, ...args) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType].forEach(cb => {
        //                 cb.call(this, ...args)
        //             });
        //         }
        //     }
        // }

        // const emit = new EventEmitter()
        // emit.on('click', function (name) {
        //     console.log(name)
        // })
        // emit.emit('click', '111')


        // Todo: 手写-防抖和节流  他们的背景
        // 防抖：一段时间内执行一次
        // function debounce(cb, delay = 1000) {
        //     let timer
        //     return function (...args) {
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             cb.call(this, ...args)
        //         }, delay);
        //     }
        // }
        // const print = function (i) {
        //     console.log(i)
        // }
        // for (let i = 0; i < 5; i++) {
        //     debounce(print)(i)
        // }

        // 节流：每隔一段时间执行一次
        // function throttle (fn, delay = 300) {
        //     let isRunning = false, timer
        //     return (...args) => {
        //         if (isRunning) {
        //             return 
        //         }
        //         isRunning = true
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //             isRunning = false
        //         }, delay);
        //     }
        // }

        // Todo: virtual Dom => real Dom

        // 手写解析器
        // const vNode = {
        //     tag: 'div',
        //     attrs: {
        //         className: 'test'
        //     },
        //     children: [{
        //         tag: 'div',
        //         attrs: {
        //             className: 'haha'
        //         },
        //         children: [{
        //             tag: 'span',
        //             attrs: {
        //                 className: 'haha'
        //             }
        //         }]
        //     }]
        // }
        // // 目标结果是啥？
        // function _render(vNode) {
        //     const dom = document.createElement(vNode?.tag)
        //     if (vNode?.children?.length) {
        //         vNode.children.forEach(childNode => {
        //             dom.appendChild(_render(childNode))
        //         });
        //     }
        //     return dom
        // }
        // const body = document.getElementsByTagName('body')[0]
        // body.appendChild(_render(vNode))


        // Todo: 对象 flatten 扁平化
        // const obj = 
        // {
        //     a: {
        //         b: 1,
        //         c: 2,
        //         d: { e: 5 }
        //     },
        //     b: [1, 3, { a: 2, b: 3 }],
        //     c: 3
        // }
        // // flatten(obj) 结果返回如下
        // {
        //  'a.b': 1,
        //  'a.c': 2,
        //  'a.d.e': 5,
        //  'b[0]': 1,
        //  'b[1]': 3,
        //  'b[2].a': 2,
        //  'b[2].b': 3,
        //   c: 3
        // }

        function getTepy(ele) {
            return Object.prototype.toString.call(ele).slice(8, -1)
        }
        // function flatten(sourceObj) {
        //     const targetObj = {}, currentKeyPath = ''

        //     function inner(currentVal, currentKeyPath) {
        //         if (getTepy(currentVal) == 'Array') {
        //             currentVal.forEach((arrEle, index) => {
        //                 inner(arrEle, `${currentKeyPath}[${index}]`)
        //             })
        //         } else if (getTepy(currentVal) == 'Object') {
        //             Object.keys(currentVal).forEach(key => {
        //                 const keyPath = currentKeyPath ? `${currentKeyPath}.${key}` : `${key}`
        //                 inner(currentVal[key], `${keyPath}`)
        //             })
        //         } else {
        //             targetObj[currentKeyPath] = currentVal
        //         }
        //     }
        //     inner(sourceObj, currentKeyPath)
        //     return targetObj
        // }
        // console.log(flatten(obj))


        // // Todo: 问题将 flatten 的对象还原
        // const input = {
        //     "a.b": 1,
        //     "a.c": 2,
        //     "a.d.e": 5,
        //     "b[0]": 1,
        //     "b[1]": 3,
        //     "b[2].a": 2,
        //     "b[2].b": 3,
        //     "c": 3
        // }

        // function recovery(sourceObj) {
        //     let targetObj = {}
        //     Object.keys(sourceObj).forEach(key => {
        //         const keyList = key.split('.')
        //         let currKeyStr = ''
        //         keyList.forEach(item => {
        //             currKeyStr += `[${item}]`
        //         })
        //         targetObj[currKeyStr] = sourceObj[key]
        //     })
        //     return targetObj
        // }
        // function recovery(source) {
        //     if (getTepy(source) != 'Object') {
        //         return
        //     }
        //     let result = {}
        //     for (const key in source) {
        //         if (Object.hasOwnProperty.call(source, key)) {
        //             parseKey(key, source[key])
        //         }
        //     }
        //     function parseKey(key, value) {
        //         if (key.indexOf('.') > -1) {
        //             let keyList = key.split('.')
        //             // Todo
        //             keyList.forEach((keyItem, index) => {
        //                 // if () {
        //                 // } else {
        //                 // }
        //             })
        //         } else {
        //             result[key] = value
        //         }
        //     }
        //     return result
        // }
        // 测试
        const input = {
            // 'a.b': 1,
            // 'a.c': 2,
            // 'b[2].a': 2,
            // 'a.d.e': 5,
            'b[0]': 1,
            'b[1]': 3,
            'b[2].b': 3,
            // 'c': 3
        };

        // const input = {
        //     a: {
        //         b: 1,
        //         c: 2,
        //         d: { e: 5 }
        //     }
        // }

        // const input = {
        //     "a.b": 1,
        //     "a.c": 2,
        //     "a.d.e": 5
        // }

        // function transformObject(sourceObj) {
        //     let result = {}
        //     Object.keys(sourceObj).forEach(key => {
        //         const keyList = key.split(/[\.\[\]]+/).filter(Boolean)
        //         let currentLevel = result
        //         const value = sourceObj[key]
        //         for (let i = 0; i < keyList.length; i++) {
        //             const path = keyList[i];
        //             if (i < keyList.length - 1) {
        //                 if (currentLevel[path] == undefined) {
        //                     currentLevel[path] = Number.isNaN(Number((keyList[i + 1]))) ? {} : []
        //                 }
        //                 currentLevel = currentLevel[path]
        //             } else if (i == keyList.length - 1) {
        //                 currentLevel[path] = value
        //             }
        //         }
        //     })
        //     return result
        // }

        // function transformObject(obj) {
        //     const result = {};
        //     for (let key in obj) {
        //         if (obj.hasOwnProperty(key)) {
        //             let value = obj[key];
        //             const keys = key.split(/[\.\[\]]+/).filter(Boolean);
        //             let current = result;
        //             for (let i = 0; i < keys.length; i++) {
        //                 const part = keys[i];
        //                 if (i === keys.length - 1) {
        //                     current[part] = value; // 赋值
        //                 } else {
        //                     if (current[part] === undefined) {
        //                         current[part] = isNaN(Number(keys[i + 1])) ? {} : [];
        //                     }
        //                 }
        //                 current = current[part];
        //             }
        //         }
        //     }
        //     return result;
        // }

        console.log(JSON.stringify(transformObject(input), null, 2))

        































    </script>
</body>

</html>