<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hand review 1</title>
</head>

<body>
    <script>
        // Todo: 手写 bind
        // 返回一个函数，这个函数，
        // 1、作用域内部的this，指向 bind第一个参数，
        // 2、返回的函数，实参可以衔接之前bind第一个之后的所有参数
        // 核心思路 => 是将 hello.bind(me) => me.hello()
        // var name = 'test',
        // me = {
        //     name: 'zzy'
        // }
        // Function.prototype.myBind = function () {
        //     const argsArr = Array.from(arguments)
        //     const context = argsArr.slice(0, 1).shift()
        //     const restArgs = argsArr.slice(1)
        //     const fn = this
        //     const result = function () {
        //         const argsList = restArgs.concat(Array.from(arguments).slice())
        //         context.fn = fn
        //         context.fn(...argsList)
        //         delete context.fn
        //     }
        //     // Todo: 继承原函数的原型链
        //     result.prototype = Object.create(this.prototype)
        //     return result
        // }
        // function hello () { 
        //     console.log('my name is: ', this.name)
        // }
        // // hello()
        // // hello.myBind(me)()


        // Todo: 手写 Promise 实现，.then()方法，.all()方法
        // const request = function () {
        //     setTimeout(() => {
        //         console.log('request end')
        //     }, 2000);
        // }
        // request()

        // const request = function () {
        //     return new Promise(function(resolve, reject) {
        //         setTimeout(() => {
        //             console.log('request end')
        //             resolve()
        //         }, 2000);
        //     })
        // }
        // request().then(() => console.log('111'))

        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     // 异步执行的情况
        //     if (this.status === 'pending') {
        //         if (onFulfilled) {
        //             this.successList.push(() => onFulfilled(this.res))
        //         }
        //         if (onRejected) {
        //             this.failedList.push(() => onRejected(this.error))
        //         }
        //     }
        //     // 同步的话呢?
        //     if (this.status === 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.res))
        //     }
        //     if (this.status === 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.error))
        //     }
        // }

        // 问题是啥？能支持异步调用吗？
        // 利用 eventLoop 就可以做到。将要执行的函数保存到 list 当中
        // new MyPromise(function(resolve, reject) {
        //   setTimeout(function() {
        //     resolve('hello world~')
        //   }, 2000)
        // }).then(res => {  
        //   console.log(res)
        //   return 'asdas'
        // })


        // 链式调用？
        // new Promise(fn).then().then()
        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new MyPromise(function (resolve, rejected) {
        //         // 异步执行的情况
        //         if (that.status === 'pending') {
        //             if (onFulfilled) {
        //                 that.successList.push(() => {
        //                     setTimeout(() => {
        //                         console.log('that', that)
        //                         let x = onFulfilled(that.res)
        //                         // x 的返回值，
        //                         // 可能是 promise, 
        //                         // 也可能是普通对象
        //                         // 需要判断循环引用吗？
        //                         resolvePromise(p2, x, resolve, rejected)
        //                     }, 0);
        //                 })

        //             }
        //             if (onRejected) {
        //                 that.failedList.push(() => {
        //                     setTimeout(() => {
        //                         onRejected(that.error)
        //                     }, 0);
        //                 })
        //             }
        //         }
        //         // 同步的话呢?
        //         if (that.status === 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 setTimeout(() => {
        //                     onFulfilled(that.res)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status === 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     onRejected(that.error)
        //                 }, 0);
        //             })
        //         }
        //     })
        //     return p2
        // }

        // // 判断，第一个 then 中，onFulfilled 执行的返回结果是啥。
        // function resolvePromise(p2, x, resolve, reject) {
        //     // 
        //     if (p2 === x) {
        //         return reject('erro')
        //     }
        //     if (x !== null && (typeof x == 'object' || typeof x == 'function')) {
        //         let called = false
        //         // 不用开关控制的结果是什么？
        //         try {
        //             let then = x.then
        //             if (typeof then == 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, err => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // class MyPromise {
        //     constructor(executor) {
        //         this.status = 'pending'
        //         this.value = ''
        //         this.error = ''
        //         this.resolveQueue = []
        //         this.rejectQueue = []
        //         const resolve = res => {
        //             if (this.status === 'pending') {
        //                 this.status = 'fulfilled'
        //                 this.value = res
        //                 this.resolveQueue.forEach(fn => fn())
        //             }
        //         }
        //         const reject = err => {
        //             if (this.status === 'pending') {
        //                 this.status = 'rejected'
        //                 this.error = err
        //                 this.rejectQueue.forEach(fn => fn())
        //             }
        //         }
        //         executor(resolve, reject)
        //     }
        //     // 偶有的函数执行都是在resolve 这一步做的
        //     then(onFulfilled, onRejected) {
        //         let promise2
        //         promise2 = new Promise((resolve, reject) => {
        //             if (this.status === 'pending') {
        //                 // 这个回调函数的这行有多种可能性, 还有在写 onFulfilled/onRejected 必须要 return 这个值x
        //                 // 1. x = 普通对象
        //                 // 2. x = promise对象
        //                 this.resolveQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onFulfilled(this.value)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })
        //                 this.rejectQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onRejected(this.error)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })

        //             }
        //             // 前一个promise的状态已经改变就不需要 Push 了
        //             if (this.status === "fulfilled") {
        //                 setTimeout(() => {
        //                     let x = onFullfilled(this.value)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //             if (this.status === "rejected") {
        //                 setTimeout(() => {
        //                     let x = onRejected(this.error)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //         })
        //         return promise2
        //     }
        // }

        // new MyPromise(function (resolve, reject) {
        //     setTimeout(function () {
        //         resolve('hello world~')
        //     }, 2000)
        // }).then(res => {
        //     console.log(res)
        //     return 'asdas'
        // }).then(res => {
        //     console.log(res)
        // })

        // 链式调用

        // MyPromise.all = function (promiseList = []) {
        //     let count = 0, len = promiseList.length, resultList = []
        //     return new MyPromise(function (resolve, reject) {
        //         for (let index = 0; index < len; index++) {
        //             const element = array[index];
        //             element.then(res => {
        //                 count++
        //                 resultList.push(res)
        //                 if (resultList.len === count) {
        //                     resolve(resultList)
        //                 } else {
        //                     reject()
        //                 }
        //             })
        //         }
        //     })
        // }
        // // catch
        // MyPromise.prototype.catch = function (onRejected) {
        //     return this.then(null, onRejected)
        //     // ...
        // }
        // // resolve
        // MyPromise.resolve = function (res) {
        //     return new MyPromise((resolve, reject) => {
        //         resolve(res)
        //     })
        // }

        // x 是 onFulfilled 的返回
        // 要去判断 x 到底是什么情况？
        // function resolvePromise(p2, x, resolve, reject) {
        //     if (p2 === x) {
        //         return reject('error')
        //     }
        //     let called = false
        //     if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
        //         try {
        //              // 依据 promise A+ 规范，x 为 promise
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, (err) => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }


        // 手写 Promise 实现
        // Promise 解决了什么问题？
        // 解决了，由于js单线程的异步回调特性-解决代码的结构的异步回调地狱的问题。
        // 内部有三种状态， pending ， fulfilled ，rejected 。初始态是 pending，成功fulfilled，
        // 失败 rejected，状态一旦发生切换，就是不可改变的。
        // function FakePromise(executor) {
        //     this.status = 'pending'
        //     this.value = ''
        //     this.error = ''
        //     this.failedList = []
        //     this.successList = []
        //     const resolve = (value) => {
        //         if (this.status == 'pending') {
        //             this.status == 'fulfilled'
        //             this.value = value
        //             this.successList.forEach(cb => cb())
        //         }
        //     }
        //     const reject = (err) => {
        //         if (this.status == 'pending') {
        //             this.status == 'rejected'
        //             this.error = err
        //             this.failedList.forEach(cb => cb())
        //         }
        //     }

        //     try {
        //         executor(resolve, reject)
        //     } catch (error) {

        //     }
        // }
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     if (this.status == 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //     }
        //     if (this.status == 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        //     if (this.status == 'pending') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        // }

        // 简易实现
        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve()
        //     }, 2000);
        // }).then(() => console.log('111'))

        // 实现 then 的链式调用
        // 
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new FakePromise(function (resolve, reject) {
        //         if (that.status == 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //         // 思考问题：then的链式调用取决于什么？
        //         // 1、在第一个 then 之后返回一个promise 对象
        //         // 2、resolve 之后 才可以持续调用是吧？那么什么时候才可以 resolve 呢？
        //         // 3、这要去判断 第一个 then中 onFulfilled 值的返回情况
        //         if (this.status == 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     let x = onRejected(that.value)
        //                     resolvePromise(p2, x, resolve, reject)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status == 'pending') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //             onRejected && that.failedList.push(() => {
        //                 let x = onRejected(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //     })
        //     return p2
        // }

        // function resolvePromise(p2, x, resolve, reject) {
        //     // 排除循环引用的 case
        //     if (p2 === x) {
        //         reject(new Error('exist cycle ...'))
        //     }
        //     if (x !== null && (typeof x === 'function' || typeof x === 'object')) {
        //         let called = false
        //         try {
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) {
        //                         return
        //                     }
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }
        //                     , err => {
        //                         if (called) {
        //                             return
        //                         }
        //                         called = true
        //                         reject(err)
        //                     })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) {
        //                 return
        //             }
        //             called = true
        //             reject(err)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve('111')
        //     }, 2000);
        // }).then(res => {
        //     console.log('then 1 res', res)
        //     return 'second p2'
        // }).then((res) => {
        //     console.log('then 2 res', res)
        // })

        // Todo: 手写寄生虫组合 继承
        // 面向对象编程，解决的问题是啥？
        // 封装，继承，多态

        // function Parent (name) {
        //     this.name = name
        //     this.say()
        // }

        // Parent.prototype.say = function () {
        //     console.log('My name is ', this.name)
        // }
        // new Parent('zgy')

        // function Son(name) {
        //     Parent.call(this, name)
        // }
        // Son.prototype = Object.create(Parent.prototype)
        // new Son('zzy')

        // Todo: 手写 new 操作符
        // new 主要完成了以下几个操作：
        // 创建一个空的对象。
        // 将该对象的 __proto__ 属性指向构造函数的 prototype。
        // 执行构造函数，将 this 指向该对象。

        // 如果构造函数没有显式返回对象，默认返回新创建的对象。

        // function myNew(constructor, ...args) {
        //     // 1
        //     // const obj = Object.create(ClassFn.prototype)

        //     const obj = {}
        //     obj.__proto__ = constructor.prototype
        //     const result = constructor.call(obj, ...args)

        //     return result instanceof Object ? result : obj;
        // }

        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        // }
        // Person.prototype.sayHello = function () {
        //     console.log(`Hello, my name is ${this.name}, and I am ${this.age} years old.`);
        // };
        // // 使用 myNew 来模拟 new 操作符
        // const person1 = myNew(Person, 'Alice', 25);
        // person1.sayHello();


        // Todo: 手写 setTimeout 模拟实现 setinterval
        // 思路是啥？
        // 在延时器内部调用延时器

        // function mySetInternal(fn, time = 100) {
        //     let timer, isClear = false
        //     function interval() {
        //         if (isClear) {
        //             isClear = false
        //             clearTimeout(timer)
        //             return
        //         }
        //         fn()
        //         timer = setTimeout(interval, time);
        //     }
        //     timer = setTimeout(interval, time);
        //     return () => {
        //         isClear = true
        //     }
        // }

        // Todo: 手写-发布订阅模式 EventEmitter 实现

        // class EventEmitter {
        //     constructor() {
        //         this.eventMap = Object.create(null)
        //     }
        //     on(eventType, fn) {
        //         // 第一步：检测是否存在，不存在则初始化
        //         if (!this.eventMap[eventType]) {
        //             this.eventMap[eventType] = []
        //         }
        //         // 第一步：赋值
        //         this.eventMap[eventType].push(fn)
        //     }
        //     remove(eventType, fn) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType] = this.eventMap[eventType].filter(cb => cb != fn)
        //         }
        //     }
        //     once(eventType, fn) {
        //         const cb = () => {
        //             fn()
        //             this.remove(eventType)
        //         }
        //         this.on(eventType, cb)
        //     }

        //     emit(eventType, ...args) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType].forEach(cb => {
        //                 cb.call(this, ...args)
        //             });
        //         }
        //     }
        // }

        // const emit = new EventEmitter()
        // emit.on('click', function (name) {
        //     console.log(name)
        // })
        // emit.emit('click', '111')


        // Todo: 手写-防抖和节流  他们的背景
        // 防抖：一段时间内执行一次
        // function debounce(cb, delay = 1000) {
        //     let timer
        //     return function (...args) {
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             cb.call(this, ...args)
        //         }, delay);
        //     }
        // }
        // const print = function (i) {
        //     console.log(i)
        // }
        // for (let i = 0; i < 5; i++) {
        //     debounce(print)(i)
        // }

        // 节流：每隔一段时间执行一次
        // function throttle (fn, delay = 300) {
        //     let isRunning = false, timer
        //     return (...args) => {
        //         if (isRunning) {
        //             return 
        //         }
        //         isRunning = true
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //             isRunning = false
        //         }, delay);
        //     }
        // }

        // Todo: virtual Dom => real Dom

        // 手写解析器
        // const vNode = {
        //     tag: 'div',
        //     attrs: {
        //         className: 'test'
        //     },
        //     children: [{
        //         tag: 'div',
        //         attrs: {
        //             className: 'haha'
        //         },
        //         children: [{
        //             tag: 'span',
        //             attrs: {
        //                 className: 'haha'
        //             }
        //         }]
        //     }]
        // }
        // // 目标结果是啥？
        // function _render(vNode) {
        //     const dom = document.createElement(vNode?.tag)
        //     if (vNode?.children?.length) {
        //         vNode.children.forEach(childNode => {
        //             dom.appendChild(_render(childNode))
        //         });
        //     }
        //     return dom
        // }
        // const body = document.getElementsByTagName('body')[0]
        // body.appendChild(_render(vNode))

        // Todo: 最长回文串
        // 给你一个字符串 s，找到 s 中最长的回文子串
        // 示例 1：
        // 输入：s = "babad"
        // 输出："bab"
        // 解释："aba" 同样是符合题意的答案。
        // 示例 2：
        // 输入：s = "cbbd"
        // 输出："bb"
        /**
         * @param {string} s
         * @return {string}
         * 思路是啥：回文串一定是连续的子串，所以，双重循环，列举出所有的连续子串，
         * 判断他们是不是回文串，如果是的话，记录长度，以及起始下标，后面可以截取字符串。
         */
        // var longestPalindrome = function (s) {
        //     // 先判断字符串的长度
        //     if (s.length < 2) {
        //         return s.length
        //     }
        //     let maxLen = 1
        //     let begin = 0
        //     for (let i = 0; i < s.length - 1; i++) {
        //         for (let j = 1; j < s.length; j++) {
        //             let currLen = j - i + 1
        //             if (currLen > maxLen && isPalindrome(s, i, j)) {
        //                 maxLen = currLen
        //                 begin = i
        //             }
        //         }
        //     }
        //     console.log('begin', begin, 'maxLen', maxLen)
        //     return s.substr(begin, maxLen)
        // };

        // // 是否是回文串
        // const isPalindrome = function (s, left, right) {
        //     while (left < right) {
        //         if (s[left] !== s[right]) {
        //             return false
        //         }
        //         left++
        //         right--
        //     }
        //     return true
        // }
        // console.log(longestPalindrome("babad"))
        // console.log(longestPalindrome("cbbd"))


        // Todo: 实现一个函数，入参为一个字符串，需要将字符串中出现次数最多的字符移除，
        // 并按原来的顺序返回剩余的字符串。
        // 例1：
        // 输入：'abc'
        // 输出：''
        // 例2：
        // 输入:  'abbc'
        // 输出:  'ac'  
        // fn('abc') -> ''
        // fn('abbc') -> 'ac'

        // function removeMostFrequentChar(s) {
        //     if (s.length === 0) return s; // 如果字符串为空，直接返回
        //     // 1. 统计字符出现次数
        //     const charCount = {};
        //     for (const char of s) {
        //         charCount[char] = (charCount[char] || 0) + 1;
        //     }
        //     // 2. 找到出现次数最多的字符
        //     const maxCount = Math.max(...Object.values(charCount)); // 最大出现次数
        //     const charsToRemove = new Set(); // 存储需要移除的字符
        //     for (const [char, count] of Object.entries(charCount)) {
        //         if (count === maxCount) {
        //             charsToRemove.add(char);
        //         }
        //     }
        //     // 3. 移除出现次数最多的字符
        //     let result = '';
        //     for (const char of s) {
        //         if (!charsToRemove.has(char)) { // 如果字符不需要移除
        //             result += char; // 添加到结果中
        //         }
        //     }
        //     return result;
        // }

        // Todo: 冒泡排序：
        // 给定一个整数数组 nums，请你实现一个冒泡排序算法，将数组从小到大排序。
        // 输入: nums = [5, 2, 9, 1, 5, 6]
        // 输出: [1, 2, 5, 5, 6, 9]

        // function solution(nums) {
        //     for (let i = 0; i < nums.length; i++) {
        //         for (let j = 0; j < nums.length - i; j++) {
        //             if (nums[j] > nums[j + 1]) {
        //                 let temp = nums[j]
        //                 nums[j] = nums[j + 1]
        //                 nums[j + 1] = temp
        //             }
        //         }
        //     }
        //     return nums
        // }
        // console.log(solution([5, 2, 9, 1, 5, 6]))


        // Todo: 两数之和
        // function sumOfDigits(num) {
        //     // 计算数字的各位数字之和
        //     return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        // }

        // function solution(N) {
        //     let targetSum = sumOfDigits(N) * 2;  // 目标数字之和是 N 数字之和的两倍
        //     let candidate = N + 1;  // 从 N+1 开始查找
        //     // 不断递增查找，直到找到满足条件的数字
        //     while (sumOfDigits(candidate) !== targetSum) {
        //         candidate++;
        //     }
        //     return candidate;  // 返回找到的数字
        // }

        // // 示例测试
        // console.log(solution(14));  // 输出: 19
        // console.log(solution(10));  // 输出: 11
        // console.log(solution(99));  // 输出: 9999

        











































    </script>
</body>

</html>