<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hand review 1</title>
</head>

<body>
    <script>
        // Todo: 手写 bind
        // 返回一个函数，这个函数，
        // 1、作用域内部的this，指向 bind第一个参数，
        // 2、返回的函数，实参可以衔接之前bind第一个之后的所有参数
        // 核心思路 => 是将 hello.bind(me) => me.hello()
        // var name = 'test',
        // me = {
        //     name: 'zzy'
        // }
        // Function.prototype.myBind = function () {
        //     const argsArr = Array.from(arguments)
        //     const context = argsArr.slice(0, 1).shift()
        //     const restArgs = argsArr.slice(1)
        //     const fn = this
        //     const result = function () {
        //         const argsList = restArgs.concat(Array.from(arguments).slice())
        //         context.fn = fn
        //         context.fn(...argsList)
        //         delete context.fn
        //     }
        //     // Todo: 继承原函数的原型链
        //     result.prototype = Object.create(this.prototype)
        //     return result
        // }
        // function hello () { 
        //     console.log('my name is: ', this.name)
        // }
        // // hello()
        // // hello.myBind(me)()

        // // Todo: 手写 bind 实现
        // // 返回一个函数，这个函数
        // // this 指向问题，以弱绑定的方式去实现强绑定
        // // 例如
        // var name = 'wahaha'
        // function helloName (age) {
        //     console.log(this?.name, ' and age is ', age)
        // }
        // // helloName()
        // const you = {
        //     name: 'gpt-4'
        // }
        // helloName.bind(you)(18)
        // 解题思路：将 helloName.bind(you)() => you.helloName() 执行
        // 1：拿到 context
        // 2：绑定
        // 连接参数的能力
        // 3：执行
        // 4：删除
        // Function.prototype.meBind = function () {
        //     const argsArr = Array.from(arguments)
        //     const context = argsArr.slice(0, 1).shift()
        //     const remainingArgs = argsArr.slice(1)
        //     const fn = this
        //     const returnFn = function () {
        //         context.fn = fn
        //         const otherArgs = Array.from(arguments)
        //         const allArgs = remingArgs.concat(otherArgs)
        //         context.fn(...allArgs)
        //         // Todo: 继承原函数的原型链
        //         returnFn.prototype = Object.create(this.prototype)
        //         delete context.fn
        //     }
        //     return returnFn
        // }
        // helloName.meBind(you)(11)


        // Todo: 手写 Promise 实现，.then()方法，.all()方法

        // const request = function () {
        //     setTimeout(() => {
        //         console.log('request end')
        //     }, 2000);
        // }
        // request()

        // const request = function () {
        //     return new Promise(function(resolve, reject) {
        //         setTimeout(() => {
        //             console.log('request end')
        //             resolve()
        //         }, 2000);
        //     })
        // }
        // request().then(() => console.log('111'))

        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     // 异步执行的情况
        //     if (this.status === 'pending') {
        //         if (onFulfilled) {
        //             this.successList.push(() => onFulfilled(this.res))
        //         }
        //         if (onRejected) {
        //             this.failedList.push(() => onRejected(this.error))
        //         }
        //     }
        //     // 同步的话呢?
        //     if (this.status === 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.res))
        //     }
        //     if (this.status === 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.error))
        //     }
        // }

        // 问题是啥？能支持异步调用吗？
        // 利用 eventLoop 就可以做到。将要执行的函数保存到 list 当中
        // new MyPromise(function(resolve, reject) {
        //   setTimeout(function() {
        //     resolve('hello world~')
        //   }, 2000)
        // }).then(res => {  
        //   console.log(res)
        //   return 'asdas'
        // })


        // 链式调用？
        // new Promise(fn).then().then()
        // function MyPromise(executor) {
        //     this.status = 'pending'
        //     this.successList = []
        //     this.failedList = []
        //     this.res = ''
        //     this.error = ''

        //     const resolve = value => {
        //         if (this.status == 'pending') {
        //             this.status = 'fulfilled'
        //             this.res = value
        //             this.successList.forEach(onFulfilled => {
        //                 onFulfilled()
        //             });
        //         }
        //     }

        //     const reject = error => {
        //         if (this.status == 'pending') {
        //             this.status = 'rejected'
        //             this.error = error
        //             this.failedList.forEach(onRejected => {
        //                 onRejected()
        //             });
        //         }
        //     }
        //     executor(resolve, reject)
        // }

        // MyPromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new MyPromise(function (resolve, rejected) {
        //         // 异步执行的情况
        //         if (that.status === 'pending') {
        //             if (onFulfilled) {
        //                 that.successList.push(() => {
        //                     setTimeout(() => {
        //                         console.log('that', that)
        //                         let x = onFulfilled(that.res)
        //                         // x 的返回值，
        //                         // 可能是 promise, 
        //                         // 也可能是普通对象
        //                         // 需要判断循环引用吗？
        //                         resolvePromise(p2, x, resolve, rejected)
        //                     }, 0);
        //                 })

        //             }
        //             if (onRejected) {
        //                 that.failedList.push(() => {
        //                     setTimeout(() => {
        //                         onRejected(that.error)
        //                     }, 0);
        //                 })
        //             }
        //         }
        //         // 同步的话呢?
        //         if (that.status === 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 setTimeout(() => {
        //                     onFulfilled(that.res)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status === 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     onRejected(that.error)
        //                 }, 0);
        //             })
        //         }
        //     })
        //     return p2
        // }

        // // 判断，第一个 then 中，onFulfilled 执行的返回结果是啥。
        // function resolvePromise(p2, x, resolve, reject) {
        //     // 
        //     if (p2 === x) {
        //         return reject('erro')
        //     }
        //     if (x !== null && (typeof x == 'object' || typeof x == 'function')) {
        //         let called = false
        //         // 不用开关控制的结果是什么？
        //         try {
        //             let then = x.then
        //             if (typeof then == 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, err => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // class MyPromise {
        //     constructor(executor) {
        //         this.status = 'pending'
        //         this.value = ''
        //         this.error = ''
        //         this.resolveQueue = []
        //         this.rejectQueue = []
        //         const resolve = res => {
        //             if (this.status === 'pending') {
        //                 this.status = 'fulfilled'
        //                 this.value = res
        //                 this.resolveQueue.forEach(fn => fn())
        //             }
        //         }
        //         const reject = err => {
        //             if (this.status === 'pending') {
        //                 this.status = 'rejected'
        //                 this.error = err
        //                 this.rejectQueue.forEach(fn => fn())
        //             }
        //         }
        //         executor(resolve, reject)
        //     }
        //     // 偶有的函数执行都是在resolve 这一步做的
        //     then(onFulfilled, onRejected) {
        //         let promise2
        //         promise2 = new Promise((resolve, reject) => {
        //             if (this.status === 'pending') {
        //                 // 这个回调函数的这行有多种可能性, 还有在写 onFulfilled/onRejected 必须要 return 这个值x
        //                 // 1. x = 普通对象
        //                 // 2. x = promise对象
        //                 this.resolveQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onFulfilled(this.value)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })
        //                 this.rejectQueue.push(() => {
        //                     setTimeout(() => {
        //                         let x = onRejected(this.error)
        //                         resolvePromise(promise2, x, resolve, reject)
        //                     }, 0);
        //                 })

        //             }
        //             // 前一个promise的状态已经改变就不需要 Push 了
        //             if (this.status === "fulfilled") {
        //                 setTimeout(() => {
        //                     let x = onFullfilled(this.value)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //             if (this.status === "rejected") {
        //                 setTimeout(() => {
        //                     let x = onRejected(this.error)
        //                     resolvePromise(promise2, x, resolve, reject)
        //                 }, 0);
        //             }
        //         })
        //         return promise2
        //     }
        // }

        // new MyPromise(function (resolve, reject) {
        //     setTimeout(function () {
        //         resolve('hello world~')
        //     }, 2000)
        // }).then(res => {
        //     console.log(res)
        //     return 'asdas'
        // }).then(res => {
        //     console.log(res)
        // })

        // 链式调用

        // MyPromise.all = function (promiseList = []) {
        //     let count = 0, len = promiseList.length, resultList = []
        //     return new MyPromise(function (resolve, reject) {
        //         for (let index = 0; index < len; index++) {
        //             const element = array[index];
        //             element.then(res => {
        //                 count++
        //                 resultList.push(res)
        //                 if (resultList.len === count) {
        //                     resolve(resultList)
        //                 } else {
        //                     reject()
        //                 }
        //             })
        //         }
        //     })
        // }
        // // catch
        // MyPromise.prototype.catch = function (onRejected) {
        //     return this.then(null, onRejected)
        //     // ...
        // }
        // // resolve
        // MyPromise.resolve = function (res) {
        //     return new MyPromise((resolve, reject) => {
        //         resolve(res)
        //     })
        // }

        // x 是 onFulfilled 的返回
        // 要去判断 x 到底是什么情况？
        // function resolvePromise(p2, x, resolve, reject) {
        //     if (p2 === x) {
        //         return reject('error')
        //     }
        //     let called = false
        //     if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
        //         try {
        //              // 依据 promise A+ 规范，x 为 promise
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) return
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }, (err) => {
        //                     if (called) return
        //                     called = true
        //                     reject(err)
        //                 })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) return
        //             called = true
        //             reject(error)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }


        // 手写 Promise 实现
        // Promise 解决了什么问题？
        // 解决了，由于js单线程的异步回调特性-解决代码的结构的异步回调地狱的问题。
        // 内部有三种状态， pending ， fulfilled ，rejected 。初始态是 pending，成功fulfilled，
        // 失败 rejected，状态一旦发生切换，就是不可改变的。
        // function FakePromise(executor) {
        //     this.status = 'pending'
        //     this.value = ''
        //     this.error = ''
        //     this.failedList = []
        //     this.successList = []
        //     const resolve = (value) => {
        //         if (this.status == 'pending') {
        //             this.status == 'fulfilled'
        //             this.value = value
        //             this.successList.forEach(cb => cb())
        //         }
        //     }
        //     const reject = (err) => {
        //         if (this.status == 'pending') {
        //             this.status == 'rejected'
        //             this.error = err
        //             this.failedList.forEach(cb => cb())
        //         }
        //     }

        //     try {
        //         executor(resolve, reject)
        //     } catch (error) {

        //     }
        // }
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     if (this.status == 'fulfilled') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //     }
        //     if (this.status == 'rejected') {
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        //     if (this.status == 'pending') {
        //         onFulfilled && this.successList.push(() => onFulfilled(this.value))
        //         onRejected && this.failedList.push(() => onRejected(this.value))
        //     }
        // }

        // 简易实现
        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve()
        //     }, 2000);
        // }).then(() => console.log('111'))

        // 实现 then 的链式调用
        // 
        // FakePromise.prototype.then = function (onFulfilled, onRejected) {
        //     const that = this
        //     let p2 = new FakePromise(function (resolve, reject) {
        //         if (that.status == 'fulfilled') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //         // 思考问题：then的链式调用取决于什么？
        //         // 1、在第一个 then 之后返回一个promise 对象
        //         // 2、resolve 之后 才可以持续调用是吧？那么什么时候才可以 resolve 呢？
        //         // 3、这要去判断 第一个 then中 onFulfilled 值的返回情况
        //         if (this.status == 'rejected') {
        //             onRejected && that.failedList.push(() => {
        //                 setTimeout(() => {
        //                     let x = onRejected(that.value)
        //                     resolvePromise(p2, x, resolve, reject)
        //                 }, 0);
        //             })
        //         }
        //         if (that.status == 'pending') {
        //             onFulfilled && that.successList.push(() => {
        //                 let x = onFulfilled(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //             onRejected && that.failedList.push(() => {
        //                 let x = onRejected(that.value)
        //                 resolvePromise(p2, x, resolve, reject)
        //             })
        //         }
        //     })
        //     return p2
        // }

        // function resolvePromise(p2, x, resolve, reject) {
        //     // 排除循环引用的 case
        //     if (p2 === x) {
        //         reject(new Error('exist cycle ...'))
        //     }
        //     if (x !== null && (typeof x === 'function' || typeof x === 'object')) {
        //         let called = false
        //         try {
        //             let then = x.then
        //             if (typeof then === 'function') {
        //                 then.call(x, y => {
        //                     if (called) {
        //                         return
        //                     }
        //                     called = true
        //                     resolvePromise(p2, y, resolve, reject)
        //                 }
        //                     , err => {
        //                         if (called) {
        //                             return
        //                         }
        //                         called = true
        //                         reject(err)
        //                     })
        //             } else {
        //                 resolve(x)
        //             }
        //         } catch (error) {
        //             if (called) {
        //                 return
        //             }
        //             called = true
        //             reject(err)
        //         }
        //     } else {
        //         resolve(x)
        //     }
        // }

        // new FakePromise(function (resolve, reject) {
        //     setTimeout(() => {
        //         console.log('request end')
        //         resolve('111')
        //     }, 2000);
        // }).then(res => {
        //     console.log('then 1 res', res)
        //     return 'second p2'
        // }).then((res) => {
        //     console.log('then 2 res', res)
        // })

        // Todo: 手写寄生虫组合 继承
        // 面向对象编程，解决的问题是啥？
        // 封装，继承，多态

        // function Parent (name) {
        //     this.name = name
        //     this.say()
        // }

        // Parent.prototype.say = function () {
        //     console.log('My name is ', this.name)
        // }
        // new Parent('zgy')

        // function Son(name) {
        //     Parent.call(this, name)
        // }
        // Son.prototype = Object.create(Parent.prototype)
        // new Son('zzy')

        // Todo: 手写 new 操作符
        // new 主要完成了以下几个操作：
        // 创建一个空的对象。
        // 将该对象的 __proto__ 属性指向构造函数的 prototype。
        // 执行构造函数，将 this 指向该对象。

        // 如果构造函数没有显式返回对象，默认返回新创建的对象。

        // function myNew(constructor, ...args) {
        //     // 1
        //     // const obj = Object.create(ClassFn.prototype)

        //     const obj = {}
        //     obj.__proto__ = constructor.prototype
        //     const result = constructor.call(obj, ...args)

        //     return result instanceof Object ? result : obj;
        // }

        // function Person(name, age) {
        //     this.name = name;
        //     this.age = age;
        // }
        // Person.prototype.sayHello = function () {
        //     console.log(`Hello, my name is ${this.name}, and I am ${this.age} years old.`);
        // };
        // // 使用 myNew 来模拟 new 操作符
        // const person1 = myNew(Person, 'Alice', 25);
        // person1.sayHello();


        // Todo: 手写 setTimeout 模拟实现 setinterval
        // 思路是啥？
        // 在延时器内部调用延时器

        // function mySetInternal(fn, time = 100) {
        //     let timer, isClear = false
        //     function interval() {
        //         if (isClear) {
        //             isClear = false
        //             clearTimeout(timer)
        //             return
        //         }
        //         fn()
        //         timer = setTimeout(interval, time);
        //     }
        //     timer = setTimeout(interval, time);
        //     return () => {
        //         isClear = true
        //     }
        // }

        // Todo: 手写-发布订阅模式 EventEmitter 实现

        // class EventEmitter {
        //     constructor() {
        //         this.eventMap = Object.create(null)
        //     }
        //     on(eventType, fn) {
        //         // 第一步：检测是否存在，不存在则初始化
        //         if (!this.eventMap[eventType]) {
        //             this.eventMap[eventType] = []
        //         }
        //         // 第一步：赋值
        //         this.eventMap[eventType].push(fn)
        //     }
        //     remove(eventType, fn) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType] = this.eventMap[eventType].filter(cb => cb != fn)
        //         }
        //     }
        //     once(eventType, fn) {
        //         const cb = () => {
        //             fn()
        //             this.remove(eventType)
        //         }
        //         this.on(eventType, cb)
        //     }

        //     emit(eventType, ...args) {
        //         if (this.eventMap[eventType].length) {
        //             this.eventMap[eventType].forEach(cb => {
        //                 cb.call(this, ...args)
        //             });
        //         }
        //     }
        // }

        // const emit = new EventEmitter()
        // emit.on('click', function (name) {
        //     console.log(name)
        // })
        // emit.emit('click', '111')


        // Todo: 手写-防抖和节流  他们的背景
        // 防抖：一段时间内执行一次
        // function debounce(cb, delay = 1000) {
        //     let timer
        //     return function (...args) {
        //         if (timer) {
        //             clearTimeout(timer)
        //         }
        //         timer = setTimeout(() => {
        //             cb.call(this, ...args)
        //         }, delay);
        //     }
        // }
        // const print = function (i) {
        //     console.log(i)
        // }
        // for (let i = 0; i < 5; i++) {
        //     debounce(print)(i)
        // }

        // 节流：每隔一段时间执行一次
        // function throttle (fn, delay = 300) {
        //     let isRunning = false, timer
        //     return (...args) => {
        //         if (isRunning) {
        //             return 
        //         }
        //         isRunning = true
        //         timer = setTimeout(() => {
        //             fn.call(this, ...args)
        //             isRunning = false
        //         }, delay);
        //     }
        // }

        // Todo: virtual Dom => real Dom

        // 手写解析器
        // const vNode = {
        //     tag: 'div',
        //     attrs: {
        //         className: 'test'
        //     },
        //     children: [{
        //         tag: 'div',
        //         attrs: {
        //             className: 'haha'
        //         },
        //         children: [{
        //             tag: 'span',
        //             attrs: {
        //                 className: 'haha'
        //             }
        //         }]
        //     }]
        // }
        // // 目标结果是啥？
        // function _render(vNode) {
        //     const dom = document.createElement(vNode?.tag)
        //     if (vNode?.children?.length) {
        //         vNode.children.forEach(childNode => {
        //             dom.appendChild(_render(childNode))
        //         });
        //     }
        //     return dom
        // }
        // const body = document.getElementsByTagName('body')[0]
        // body.appendChild(_render(vNode))


        // Todo: 对象 flatten 扁平化
        // const obj = 
        // {
        //     a: {
        //         b: 1,
        //         c: 2,
        //         d: { e: 5 }
        //     },
        //     b: [1, 3, { a: 2, b: 3 }],
        //     c: 3
        // }
        // // flatten(obj) 结果返回如下
        // {
        //  'a.b': 1,
        //  'a.c': 2,
        //  'a.d.e': 5,
        //  'b[0]': 1,
        //  'b[1]': 3,
        //  'b[2].a': 2,
        //  'b[2].b': 3,
        //   c: 3
        // }

        // function getTepy(ele) {
        //     return Object.prototype.toString.call(ele).slice(8, -1)
        // }
        // function flatten(sourceObj) {
        //     const targetObj = {}, currentKeyPath = ''

        //     function inner(currentVal, currentKeyPath) {
        //         if (getTepy(currentVal) == 'Array') {
        //             currentVal.forEach((arrEle, index) => {
        //                 inner(arrEle, `${currentKeyPath}[${index}]`)
        //             })
        //         } else if (getTepy(currentVal) == 'Object') {
        //             Object.keys(currentVal).forEach(key => {
        //                 const keyPath = currentKeyPath ? `${currentKeyPath}.${key}` : `${key}`
        //                 inner(currentVal[key], `${keyPath}`)
        //             })
        //         } else {
        //             targetObj[currentKeyPath] = currentVal
        //         }
        //     }
            
        //     inner(sourceObj, currentKeyPath)
        //     return targetObj
        // }
        // console.log(flatten(obj))


        // // Todo: 问题将 flatten 的对象还原
        // const input = {
        //     "a.b": 1,
        //     "a.c": 2,
        //     "a.d.e": 5,
        //     "b[0]": 1,
        //     "b[1]": 3,
        //     "b[2].a": 2,
        //     "b[2].b": 3,
        //     "c": 3
        // }

        // function recovery(sourceObj) {
        //     let targetObj = {}
        //     Object.keys(sourceObj).forEach(key => {
        //         const keyList = key.split('.')
        //         let currKeyStr = ''
        //         keyList.forEach(item => {
        //             currKeyStr += `[${item}]`
        //         })
        //         targetObj[currKeyStr] = sourceObj[key]
        //     })
        //     return targetObj
        // }
        // function recovery(source) {
        //     if (getTepy(source) != 'Object') {
        //         return
        //     }
        //     let result = {}
        //     for (const key in source) {
        //         if (Object.hasOwnProperty.call(source, key)) {
        //             parseKey(key, source[key])
        //         }
        //     }
        //     function parseKey(key, value) {
        //         if (key.indexOf('.') > -1) {
        //             let keyList = key.split('.')
        //             // Todo
        //             keyList.forEach((keyItem, index) => {
        //                 // if () {
        //                 // } else {
        //                 // }
        //             })
        //         } else {
        //             result[key] = value
        //         }
        //     }
        //     return result
        // }
        // 测试
        // const input = {
        //     // 'a.b': 1,
        //     // 'a.c': 2,
        //     // 'b[2].a': 2,
        //     // 'a.d.e': 5,
        //     'b[0]': 1,
        //     'b[1]': 3,
        //     'b[2].b': 3,
        //     // 'c': 3
        // };

        // const input = {
        //     a: {
        //         b: 1,
        //         c: 2,
        //         d: { e: 5 }
        //     }
        // }

        // const input = {
        //     "a.b": 1,
        //     "a.c": 2,
        //     "a.d.e": 5
        // }

        // function transformObject(sourceObj) {
        //     let result = {}
        //     Object.keys(sourceObj).forEach(key => {
        //         const keyList = key.split(/[\.\[\]]+/).filter(Boolean)
        //         let currentLevel = result
        //         const value = sourceObj[key]
        //         for (let i = 0; i < keyList.length; i++) {
        //             const path = keyList[i];
        //             if (i < keyList.length - 1) {
        //                 if (currentLevel[path] == undefined) {
        //                     currentLevel[path] = Number.isNaN(Number((keyList[i + 1]))) ? {} : []
        //                 }
        //                 currentLevel = currentLevel[path]
        //             } else if (i == keyList.length - 1) {
        //                 currentLevel[path] = value
        //             }
        //         }
        //     })
        //     return result
        // }

        // function transformObject(obj) {
        //     const result = {};
        //     for (let key in obj) {
        //         if (obj.hasOwnProperty(key)) {
        //             let value = obj[key];
        //             const keys = key.split(/[\.\[\]]+/).filter(Boolean);
        //             let current = result;
        //             for (let i = 0; i < keys.length; i++) {
        //                 const part = keys[i];
        //                 if (i === keys.length - 1) {
        //                     current[part] = value; // 赋值
        //                 } else {
        //                     if (current[part] === undefined) {
        //                         current[part] = isNaN(Number(keys[i + 1])) ? {} : [];
        //                     }
        //                 }
        //                 current = current[part];
        //             }
        //         }
        //     }
        //     return result;
        // }

        // console.log(JSON.stringify(transformObject(input), null, 2))

        /**
         * @param {string} s
         * @return {number}
         * 1. 先找到所有的不重复的子串
         */
        // var lengthOfLongestSubstring = function (s) {
        //     let strList = s.split(''), maxLengthStr = '', noRepeatList = []
        //     if (strList.length) {
        //         let currStr = ''
        //         strList.forEach((itemStr, index) => {
        //             if (currStr.indexOf(itemStr) == -1) {
        //                 currStr += itemStr
        //             } else {
        //                 noRepeatList.push(currStr)
        //                 currStr = itemStr
        //             }
        //         })

        //         noRepeatList.forEach(str => {
        //             if (str.length > maxLengthStr.length) {
        //                 maxLengthStr = str
        //             }
        //         })
        //     }
        //     return maxLengthStr.length
        // };

        // console.log(lengthOfLongestSubstring("dvdf"))

        // Todo: 最长不重复子串
        // 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
        // 示例 1:
        // 输入: s = "abcabcbb"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
        // 示例 2:
        // 输入: s = "bbbbb"
        // 输出: 1
        // 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
        // 示例 3:
        // 输入: s = "pwwkew"
        // 输出: 3
        // 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
        // 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

        // function lengthOfLongestSubstring(s) {
        //     let n = s.length;
        //     let left = 0; // 滑动窗口的左边界
        //     let maxLength = 0; // 记录最长子串的长度
        //     let charSet = new Set(); // 用来存储当前窗口的字符
        //     for (let right = 0; right < n; right++) {
        //         // 如果字符已经在窗口中，移动左边界
        //         while (charSet.has(s[right])) {
        //             charSet.delete(s[left]);
        //             left++;
        //         }
        //         // 将当前字符添加到窗口中
        //         charSet.add(s[right]);
        //         // 更新最大长度
        //         maxLength = Math.max(maxLength, right - left + 1);
        //     }
        //     return maxLength;
        // }

        // Todo: 最长回文串
        // 给你一个字符串 s，找到 s 中最长的回文子串
        // 示例 1：
        // 输入：s = "babad"
        // 输出："bab"
        // 解释："aba" 同样是符合题意的答案。
        // 示例 2：
        // 输入：s = "cbbd"
        // 输出："bb"
        /**
         * @param {string} s
         * @return {string}
         * 思路是啥：回文串一定是连续的子串，所以，双重循环，列举出所有的连续子串，
         * 判断他们是不是回文串，如果是的话，记录长度，以及起始下标，后面可以截取字符串。
         */
        // var longestPalindrome = function (s) {
        //     // 先判断字符串的长度
        //     if (s.length < 2) {
        //         return s.length
        //     }
        //     let maxLen = 1
        //     let begin = 0
        //     for (let i = 0; i < s.length - 1; i++) {
        //         for (let j = 1; j < s.length; j++) {
        //             let currLen = j - i + 1
        //             if (currLen > maxLen && isPalindrome(s, i, j)) {
        //                 maxLen = currLen
        //                 begin = i
        //             }
        //         }
        //     }
        //     console.log('begin', begin, 'maxLen', maxLen)
        //     return s.substr(begin, maxLen)
        // };

        // // 是否是回文串
        // const isPalindrome = function (s, left, right) {
        //     while (left < right) {
        //         if (s[left] !== s[right]) {
        //             return false
        //         }
        //         left++
        //         right--
        //     }
        //     return true
        // }
        // console.log(longestPalindrome("babad"))
        // console.log(longestPalindrome("cbbd"))


        // Todo: 实现一个函数，入参为一个字符串，需要将字符串中出现次数最多的字符移除，
        // 并按原来的顺序返回剩余的字符串。
        // 例1：
        // 输入：'abc'
        // 输出：''
        // 例2：
        // 输入:  'abbc'
        // 输出:  'ac'  
        // fn('abc') -> ''
        // fn('abbc') -> 'ac'
        // function anwser(sourceStr) {
        //     let returnStr = '', maxRepeatCountStr, obj = {};
        //     let strArr = sourceStr.split('')
        //     for (let i = 0; i < strArr.length; i++) {
        //         const str = strArr[i];
        //         if (obj[str]) {
        //             obj[str] = obj[str] + 1
        //         } else {
        //             obj[str] = 1
        //         }
        //     }
        //     const maxRepeatCount = Math.max(...Object.values(obj))
        //     Object.keys(obj).forEach(str => {
        //         if (obj[str] == maxRepeatCount) {
        //             maxRepeatCountStr = str
        //         }
        //     })
        //     // console.log('maxRepeatCountStr', maxRepeatCountStr)
        //     // const reg = new RegExp(maxRepeatCountStr, 'g')
        //     // console.log('reg', reg)
        //     // returnStr = sourceStr.replace(reg, '')
        //     // return returnStr

        //     for (const char of sourceStr) {
        //         if (maxRepeatCountStr.indexOf(char) == -1) {
        //             returnStr += char
        //         }
        //     }
        //     return returnStr
        // }
        // console.log(anwser("abbc"))


        // function removeMostFrequentChar(s) {
        //     if (s.length === 0) return s; // 如果字符串为空，直接返回
        //     // 1. 统计字符出现次数
        //     const charCount = {};
        //     for (const char of s) {
        //         charCount[char] = (charCount[char] || 0) + 1;
        //     }
        //     // 2. 找到出现次数最多的字符
        //     const maxCount = Math.max(...Object.values(charCount)); // 最大出现次数
        //     const charsToRemove = new Set(); // 存储需要移除的字符
        //     for (const [char, count] of Object.entries(charCount)) {
        //         if (count === maxCount) {
        //             charsToRemove.add(char);
        //         }
        //     }
        //     // 3. 移除出现次数最多的字符
        //     let result = '';
        //     for (const char of s) {
        //         if (!charsToRemove.has(char)) { // 如果字符不需要移除
        //             result += char; // 添加到结果中
        //         }
        //     }
        //     return result;
        // }

        // Todo: 冒泡排序：
        // 给定一个整数数组 nums，请你实现一个冒泡排序算法，将数组从小到大排序。
        // 输入: nums = [5, 2, 9, 1, 5, 6]
        // 输出: [1, 2, 5, 5, 6, 9]

        // function solution(nums) {
        //     for (let i = 0; i < nums.length; i++) {
        //         for (let j = 0; j < nums.length - i; j++) {
        //             if (nums[j] > nums[j + 1]) {
        //                 let temp = nums[j]
        //                 nums[j] = nums[j + 1]
        //                 nums[j + 1] = temp
        //             }
        //         }
        //     }
        //     return nums
        // }
        // console.log(solution([5, 2, 9, 1, 5, 6]))


        // Todo: 两数之和
        // function sumOfDigits(num) {
        //     // 计算数字的各位数字之和
        //     return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
        // }

        // function solution(N) {
        //     let targetSum = sumOfDigits(N) * 2;  // 目标数字之和是 N 数字之和的两倍
        //     let candidate = N + 1;  // 从 N+1 开始查找
        //     // 不断递增查找，直到找到满足条件的数字
        //     while (sumOfDigits(candidate) !== targetSum) {
        //         candidate++;
        //     }
        //     return candidate;  // 返回找到的数字
        // }

        // // 示例测试
        // console.log(solution(14));  // 输出: 19
        // console.log(solution(10));  // 输出: 11
        // console.log(solution(99));  // 输出: 9999


        // // Todo: 模拟获取用户偏好品牌的函数
        // function getLikedBrands(id) {
        //     return new Promise((resolve, reject) => {
        //         // 模拟获取的用户品牌偏好列表
        //         const likedBrands = {
        //             1: ["Logestyx"],
        //             10: ["Gladlear"],
        //             6: ["Burylaze Slapgalt"],
        //             7: ["Izarpure"]
        //         };

        //         setTimeout(() => {
        //             if (likedBrands[id]) {
        //                 resolve(likedBrands[id]);
        //             } else {
        //                 reject("No liked brands found for this user.");
        //             }
        //         }, 1000); // 模拟异步操作
        //     });
        // }

        // // 模拟获取用户性别对应热门品牌的函数
        // function getTopBrandsForGender(gender) {
        //     return new Promise((resolve, reject) => {
        //         // 模拟根据性别返回的热门品牌
        //         const genderBrands = {
        //             male: ["Nike", "Adidas", "Puma", "Reebok", "Under Armour"],
        //             female: ["Gucci", "Louis Vuitton", "Prada", "Chanel", "Dior"]
        //         };

        //         setTimeout(() => {
        //             if (genderBrands[gender]) {
        //                 resolve(genderBrands[gender]);
        //             } else {
        //                 reject("No top brands found for this gender.");
        //             }
        //         }, 1000); // 模拟异步操作
        //     });
        // }

        // function solution(U, N) {
        //     return new Promise((resolve, reject) => {
        //         // 1. 获取用户的偏好品牌列表
        //         getLikedBrands(U.id)
        //             .then(likedBrands => {
        //                 // 2. 获取用户的性别对应的热门品牌列表
        //                 getTopBrandsForGender(U.gender)
        //                     .then(genderBrands => {
        //                         // 3. 合并品牌列表
        //                         let resultBrands = [];

        //                         // 优先选择用户偏好品牌列表中的前 N 个品牌
        //                         resultBrands = likedBrands.slice(0, N);

        //                         // 如果用户偏好品牌不足，补充性别对应的热门品牌
        //                         if (resultBrands.length < N) {
        //                             let remainingBrands = genderBrands.filter(brand => !resultBrands.includes(brand));
        //                             resultBrands = resultBrands.concat(remainingBrands.slice(0, N - resultBrands.length));
        //                         }

        //                         // 4. 如果品牌数量仍然不足 N，则抛出错误
        //                         if (resultBrands.length < N) {
        //                             reject(new Error("数据不足"));
        //                         } else {
        //                             resolve(resultBrands); // 返回最终结果
        //                         }
        //                     })
        //                     .catch(err => reject(new Error("数据不足"))); // 性别热门品牌获取失败
        //             })
        //             .catch(err => reject(new Error("数据不足"))); // 用户偏好品牌获取失败
        //     });
        // }

        // // 测试函数
        // const user = { id: 1, gender: "male" };

        // solution(user, 5)
        //     .then(result => console.log(result))  // 输出：['Nike', 'Adidas', 'Puma', 'Reebok', 'Under Armour']
        //     .catch(err => console.error(err.message)); // 如果数据不足，抛出 "数据不足

        
















































    </script>
</body>

</html>